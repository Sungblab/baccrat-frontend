<!DOCTYPE html>
<html lang="ko" class="dark">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>골든 카지노</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <!-- Phaser 라이브러리 추가 -->
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <style>
      body {
        background: linear-gradient(135deg, #000000 0%, #1a1a1a 100%);
        font-family: "Noto Serif KR", serif;
      }

      /* 모바일 최적화 스타일 */
      body {
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }

      /* 스크롤바 스타일링 */
      .custom-scrollbar {
        scrollbar-width: thin;
        scrollbar-color: #b8860b transparent;
      }

      .custom-scrollbar::-webkit-scrollbar {
        width: 6px;
      }

      .custom-scrollbar::-webkit-scrollbar-track {
        background: transparent;
      }

      .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: #b8860b;
        border-radius: 3px;
      }

      /* 버튼 활성화 효과 */
      .choice-button.active {
        transform: scale(0.95);
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
      }

      .coin-button.active {
        transform: scale(0.95);
        box-shadow: 0 0 10px rgba(255, 223, 0, 0.3);
      }

      /* 헤더 스타일 */
      .header-container {
        background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
        border-bottom: 1px solid #b8860b;
        box-shadow: 0 4px 6px -1px rgba(184, 134, 11, 0.1);
      }

      /* 버튼 스타일 */
      .golden-btn {
        background: linear-gradient(to right, #b8860b, #daa520);
        transition: all 0.3s ease;
      }
      .golden-btn:hover {
        background: linear-gradient(to right, #daa520, #ffd700);
        transform: translateY(-2px);
      }

      /* 베팅 기록 테이블 스타일 */
      .betting-history-card {
        background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
        backdrop-filter: blur(8px);
        border-radius: 12px;
        margin-bottom: 8px;
        padding: 12px;
        border: 1px solid #b8860b;
      }

      /* 기존 스타일에 추가 */
      #historyModal {
        transition: opacity 0.3s ease-in-out;
      }

      #historyModal.hidden {
        opacity: 0;
        pointer-events: none;
      }

      #historyModal .betting-history-card {
        animation: slideUp 0.3s ease-out;
      }

      @keyframes slideUp {
        from {
          transform: translateY(20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      /* 최근 게임 결과 스타일 - Big Road */
      #recentResults {
        display: flex;
        flex-direction: row;
        overflow-x: auto;
        overflow-y: hidden;
        padding: 4px; /* 8px -> 4px */
        min-height: 90px; /* 120px -> 90px */
        align-items: flex-start;
        gap: 2px; /* 4px -> 2px */
        -webkit-overflow-scrolling: touch;
      }

      .result-column {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .result-cell {
        width: 14px; /* 18px -> 14px */
        height: 14px; /* 18px -> 14px */
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.7rem;
        font-weight: bold;
        color: white;
        text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(0, 0, 0, 0.2);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        flex-shrink: 0;
      }

      /* 예측 셀 스타일 */
      .result-cell.prediction {
        border: 2px dashed #666; /* 점선 테두리로 예측 표시 */
        opacity: 0.7;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 0.7;
        }
        50% {
          opacity: 1;
        }
      }

      /* 승리 메시지 애니메이션 */
      @keyframes winSlideIn {
        0% {
          transform: translateY(-20px) scale(0.9);
          opacity: 0;
        }
        100% {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
      }

      @keyframes winSlideOut {
        0% {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
        100% {
          transform: translateY(-20px) scale(0.9);
          opacity: 0;
        }
      }

      .win-message-enter {
        animation: winSlideIn 0.3s ease-out forwards;
      }

      .win-message-exit {
        animation: winSlideOut 0.3s ease-in forwards;
      }

      .result-cell.player {
        border: 2px solid #3b82f6; /* 파란색 테두리 */
        background-color: transparent; /* 빈 원 */
      }
      .result-cell.banker {
        border: 2px solid #ef4444; /* 빨간색 테두리 */
        background-color: transparent; /* 빈 원 */
      }
      .result-cell.tie {
        border: 2px solid #10b981; /* 녹색 테두리 */
        background-color: transparent; /* 빈 원 */
      }
      .result-cell.player-pair {
        border: 2px solid #3b82f6; /* 플레이어 페어 표시 (예: 테두리) */
      }
      .result-cell.banker-pair {
        border: 2px solid #ef4444; /* 뱅커 페어 표시 */
      }

      /* 에볼루션 스타일 베팅 영역 */
      .betting-area {
        display: flex;
        justify-content: center;
        align-items: stretch;
        gap: 4px; /* 버튼 간 간격 */
        margin-bottom: 1rem;
        padding: 0 4px;
        height: 100px; /* 모바일 기본 높이 - 120px에서 110px로 감소 */
      }

      /* 반응형 베팅 영역 높이 */
      @media (min-width: 640px) {
        .betting-area {
          height: 140px; /* sm 이상 */
          gap: 6px;
        }
      }
      @media (min-width: 768px) {
        .betting-area {
          height: 160px; /* md 이상 */
          gap: 8px;
        }
      }
      @media (min-width: 1024px) {
        .betting-area {
          /* height: 150px; */ /* lg 이상 - 높이 줄임 */
          gap: 10px;
        }
      }

      /* 패드 가로 화면 최적화 (768px ~ 1366px) */
      @media (min-width: 768px) and (max-width: 1600px) and (orientation: landscape) {
        /* 미니게임 컨테이너 높이 줄이기 */
        #miniGameContainer {
          height: 180px !important; /* 기본 288px에서 180px로 감소 */
        }

        /* 베팅 영역 높이 줄이기 */
        .betting-area {
          height: 120px !important; /* 160px에서 120px로 감소 */
          gap: 6px;
        }

        /* 베팅 옵션 패딩 줄이기 */
        .bet-option {
          padding: 2px 3px !important; /* 4px 4px에서 2px 3px로 감소 */
        }

        /* 최근 게임 결과 섹션 높이 줄이기 */
        #recentResults {
          min-height: 80px !important; /* 120px에서 80px로 감소 */
        }

        /* 마진과 패딩 줄이기 */
        .mt-2,
        .mb-2 {
          margin-top: 0.25rem !important;
          margin-bottom: 0.25rem !important;
        }

        /* 금액 선택 버튼 영역 패딩 줄이기 */
        .amount-button {
          padding: 4px 6px !important; /* 기본 패딩에서 줄임 */
          font-size: 0.75rem !important;
        }

        /* 하단 버튼 그리드 패딩 줄이기 */
        .grid.grid-cols-3 {
          margin-top: 0.25rem !important;
          margin-bottom: 0.25rem !important;
          padding-left: 0.5rem !important;
          padding-right: 0.5rem !important;
        }

        /* 헤더 높이도 약간 줄이기 */
        header {
          height: 56px !important; /* 64px에서 56px로 감소 */
        }

        main {
          padding-top: 56px !important; /* 헤더 높이에 맞춰 조정 */
        }

        /* 게임 상태 표시 영역 마진 줄이기 */
        .mt-2.lg\\:mt-1 {
          margin-top: 0.125rem !important;
        }

        /* 미니게임 컨테이너 래퍼 마진도 줄이기 */
        #miniGameContainerWrapper {
          margin-top: 0.25rem !important;
          margin-bottom: 0.25rem !important;
        }

        /* 관리자/강조 메시지 바 위치 조정 */
        #adminMessageBar {
          top: 56px !important; /* 헤더 높이에 맞춰 조정 */
        }
      }

      .bet-option {
        position: relative;
        padding: 4px 4px; /* 패딩 조정 (8px 4px -> 4px 4px) */
        border-radius: 10px; /* 모서리 둥글기 */
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        color: white;
        font-weight: bold;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
        flex-grow: 1;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        overflow: hidden;
      }

      /* P/B/T 타이틀과 카드 표시 영역 간의 간섭을 피하기 위해 타이틀 마진 조정 */
      .bet-option .title {
        font-size: 0.9rem;
        margin-bottom: 2px;
        line-height: 1.1;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        /* margin-top: 25px; */ /* 이전 스타일 제거 */
        position: relative; /* z-index 적용을 위해 */
        z-index: 10; /* 카드보다 위에 오도록 */
      }

      /* 반응형 베팅 옵션 타이틀 */
      @media (min-width: 640px) {
        .bet-option .title {
          font-size: 1rem;
        }
        .bet-option.player .title,
        .bet-option.banker .title,
        .bet-option.tie .title {
          font-size: 1rem;
        }
        .bet-option.player-pair .title,
        .bet-option.banker-pair .title {
          font-size: 0.8rem;
        }
      }
      @media (min-width: 768px) {
        .bet-option .title {
          font-size: 1.1rem;
        }
        .bet-option.player .title,
        .bet-option.banker .title,
        .bet-option.tie .title {
          font-size: 1.1rem;
        }
        .bet-option.player-pair .title,
        .bet-option.banker-pair .title {
          font-size: 0.85rem;
        }
      }
      @media (min-width: 1024px) {
        .bet-option .title {
          font-size: 1.2rem;
        }
        .bet-option.player .title,
        .bet-option.banker .title,
        .bet-option.tie .title {
          font-size: 1.2rem;
        }
        .bet-option.player-pair .title,
        .bet-option.banker-pair .title {
          font-size: 0.9rem;
        }
      }

      .bet-option .odds {
        font-size: 0.75rem; /* 배당률 폰트 크기 */
        color: rgba(255, 255, 255, 0.8);
      }

      /* P/B/T 공통 내부 스타일 */
      .bet-option.player .title,
      .bet-option.banker .title,
      .bet-option.tie .title {
        font-size: 0.9rem; /* 1.2rem -> 0.9rem으로 축소 */
        font-family: "Noto Serif KR", serif;
        font-weight: 700;
        margin-top: 4px; /* 원래 스타일 복원 또는 유지 */
      }

      .bet-option.player {
        background: linear-gradient(
          160deg,
          rgba(0, 60, 180, 0.8),
          /* 진한 파란색 계열 */ rgba(0, 40, 120, 0.9)
        );
        border: 2px solid rgba(59, 130, 246, 0.6); /* Blue */
        flex-grow: 3; /* 플레이어 영역을 더 넓게 */
      }
      .bet-option.player.active {
        transform: scale(1.03);
        box-shadow: 0 0 20px rgba(59, 130, 246, 0.8);
        border-color: rgba(96, 165, 250, 0.9);
      }

      .bet-option.banker {
        background: linear-gradient(
          160deg,
          rgba(180, 0, 0, 0.8),
          /* 진한 빨간색 계열 */ rgba(130, 0, 0, 0.9)
        );
        border: 2px solid rgba(239, 68, 68, 0.6); /* Red */
        flex-grow: 3; /* 뱅커 영역을 더 넓게 */
      }
      .bet-option.banker.active {
        transform: scale(1.03);
        box-shadow: 0 0 20px rgba(239, 68, 68, 0.8);
        border-color: rgba(248, 113, 113, 0.9);
      }

      .bet-option.tie {
        background: linear-gradient(
          160deg,
          rgba(0, 110, 60, 0.8),
          /* 진한 녹색 계열 */ rgba(0, 80, 30, 0.9)
        );
        border: 2px solid rgba(16, 185, 129, 0.6); /* Green */
        flex-grow: 1.5; /* 타이는 중간 크기 */
      }
      .bet-option.tie.active {
        transform: scale(1.03);
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.8);
        border-color: rgba(52, 211, 153, 0.9);
      }

      .bet-option.player-pair,
      .bet-option.banker-pair {
        background: linear-gradient(
          /* P PAIR, B PAIR 배경 수정 */ 160deg,
          rgba(40, 40, 90, 0.7),
          /* 약간 푸른/붉은 기운이 도는 어두운 배경 */ rgba(20, 20, 50, 0.8)
        );
        border: 1px solid rgba(107, 114, 128, 0.5);
        flex-grow: 1; /* 페어는 가장 작게 */
        justify-content: center;
        padding-top: 12px; /* P PAIR, B PAIR 텍스트 위치 조정 */
        padding-bottom: 12px;
      }
      .bet-option.player-pair {
        border-left-color: rgba(
          59,
          130,
          246,
          0.6
        ); /* 플레이어쪽 페어는 파란색 테두리 힌트 */
      }
      .bet-option.banker-pair {
        border-right-color: rgba(
          239,
          68,
          68,
          0.6
        ); /* 뱅커쪽 페어는 빨간색 테두리 힌트 */
      }

      .bet-option.player-pair .title,
      .bet-option.banker-pair .title {
        font-size: 0.75rem; /* 0.9rem -> 0.75rem으로 축소 */
        margin-bottom: 2px;
      }
      .bet-option.player-pair .odds,
      .bet-option.banker-pair .odds {
        font-size: 0.75rem;
      }

      .bet-option.player-pair.active,
      .bet-option.banker-pair.active {
        transform: scale(1.03);
        box-shadow: 0 0 15px rgba(107, 114, 128, 0.7);
        border: 1px solid rgba(156, 163, 175, 0.8);
      }

      /* P/B/T 버튼 내 통계 표시 스타일 수정 */
      .bet-stats-container {
        display: flex;
        flex-direction: column; /* 세로로 배치 */
        align-items: center; /* 중앙 정렬 */
        justify-content: center; /* 중앙 정렬 */
        gap: 4px; /* 요소 간 간격 */
        width: 100%;
        padding: 0 5px;
        margin-top: auto; /* 타이틀과 배당률 아래로 밀기 */
        margin-bottom: 5px; /* 하단 여백 추가 */
        position: relative; /* z-index 적용을 위해 */
        z-index: 10; /* 카드보다 위에 오도록 */
      }

      .bet-stats-container .percentage-circle {
        width: 32px; /* 원 크기 조정 */
        height: 32px;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.4); /* 배경 약간 더 어둡게 */
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.8rem; /* 폰트 크기 조정 */
        font-weight: bold;
        color: #ffd700;
        border: 2px solid; /* 테두리 두께 유지 */
        flex-shrink: 0;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); /* 약간의 그림자 */
      }

      .bet-option.player .percentage-circle {
        border-color: #60a5fa; /* 밝은 파랑 */
      }
      .bet-option.banker .percentage-circle {
        border-color: #f87171; /* 밝은 빨강 */
      }
      .bet-option.tie .percentage-circle {
        border-color: #34d399; /* 밝은 초록 */
      }

      .bet-stats-container .stats-details {
        display: flex;
        flex-direction: column;
        align-items: center; /* 중앙 정렬 */
        font-size: 0.65rem; /* 폰트 크기 조정 */
        color: rgba(255, 255, 255, 0.9);
        line-height: 1.1;
      }
      .bet-stats-container .stats-details .total-bet {
        font-weight: bold;
        color: white;
        font-size: 0.7rem; /* 금액 폰트 약간 키움 */
      }
      .bet-stats-container .stats-details .bettor-count {
        font-size: 0.6rem; /* 아이콘과 숫자 크기 미세 조정 */
        color: rgba(255, 255, 255, 0.7);
      }

      /* 금액 선택 영역 동그라미 버튼 스타일 유지 */
      .amount-button {
        width: 46px; /* 모바일 기본 크기 (50px -> 46px) */
        height: 46px;
        border-radius: 50%;
        background: linear-gradient(145deg, #374151, #4b5563);
        border: 2px solid #6b7280;
        color: #fbbf24;
        font-weight: 600;
        font-size: 0.65rem; /* 모바일 기본 폰트 (0.7rem -> 0.65rem) */
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        backdrop-filter: blur(10px);
      }

      .amount-button.active {
        background: linear-gradient(145deg, #b8860b, #daa520);
        color: white;
        transform: scale(1.1);
        box-shadow: 0 0 20px #daa520, 0 4px 15px rgba(0, 0, 0, 0.3);
        border: 2px solid #fbbf24;
      }
      .amount-button:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      }

      /* P PAIR, B PAIR 내부 통계 표시를 위한 스타일 추가 */
      .bet-option.player-pair .bet-stats-container,
      .bet-option.banker-pair .bet-stats-container {
        margin-top: 2px; /* odds와 간격 */
        margin-bottom: 2px; /* 하단 간격 */
        /* 기존 .bet-stats-container 스타일이 적용되지만, 필요시 여기서 P/B PAIR에 특화된 스타일 추가 가능 */
      }
      .bet-option.player-pair .percentage-circle, /* 페어 베팅에는 퍼센트 원 미표시 */
      .bet-option.banker-pair .percentage-circle {
        display: none;
      }
      /* P PAIR, B PAIR는 인원수와 금액만 표시하므로 stats-details 정렬 조정 */
      .bet-option.player-pair .stats-details,
      .bet-option.banker-pair .stats-details {
        justify-content: center; /* 수직 중앙 정렬 */
        gap: 2px; /* 금액과 인원수 간격 */
      }

      /* 카드 표시 영역 스타일 */
      .card-display-area {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 2px; /* 카드 간 간격 */
        position: absolute;
        left: 50%;
        top: 50%; /* 세로 중앙 기준으로 설정 */
        transform: translate(
          -50%,
          -85%
        ); /* 가로 중앙, 세로 약간 위로(-100%에서 -85%로) 조정 */
        height: 25px;
        z-index: 5; /* 타이틀과 통계 사이에 오도록 z-index 조정 */
        /* 버튼 내부 다른 요소들과의 간격을 위해 필요시 margin 추가 */
      }

      .card-slot {
        width: 18px; /* 카드 너비 (기존 15px에서 증가) */
        height: 25px; /* 카드 높이 (사용자 요청 반영) */
        border-radius: 3px; /* 모서리 둥글기 약간 증가 */
        background-color: rgba(255, 255, 255, 0.8);
        color: black;
        font-size: 0.8rem; /* 카드 텍스트 크기 (기존 0.7rem에서 증가) */
        font-weight: bold;
        display: flex;
        justify-content: center;
        align-items: center;
        box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
      }

      .player-cards .card-slot {
        border: 1px solid #3b82f6; /* 플레이어 카드 테두리 */
      }

      .banker-cards .card-slot {
        border: 1px solid #ef4444; /* 뱅커 카드 테두리 */
      }

      /* Scoreboard container to hold all roads */
      #scoreboardsContainer {
        display: flex;
        flex-direction: column;
        gap: 4px;
        width: 100%;
      }

      /* Derived roads container */
      #derivedRoadsContainer {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 4px;
        height: 52px; /* 고정 높이 */
      }

      /* Common style for derived road grids */
      .derived-road-grid {
        display: flex;
        flex-direction: row;
        overflow: hidden;
        gap: 2px;
        align-items: flex-start;
        padding: 2px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 4px;
        height: 100%;
      }
      .derived-road-grid .result-column {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .derived-road-cell {
        width: 7px;
        height: 7px;
        flex-shrink: 0;
        border-radius: 50%;
      }

      /* Big Eye Road: Hollow circles */
      #bigEyeRoad .derived-road-cell.player {
        /* Blue in this context */
        border: 2px solid #3b82f6 !important;
        background: transparent !important;
        background-color: transparent !important;
      }
      #bigEyeRoad .derived-road-cell.banker {
        /* Red in this context */
        border: 2px solid #ef4444 !important;
        background: transparent !important;
        background-color: transparent !important;
      }

      /* Big Eye Road 전체 셀에 대해 배경 강제 제거 */
      #bigEyeRoad .derived-road-cell {
        background: none !important;
        background-color: transparent !important;
      }

      /* Small Road: Solid circles */
      #smallRoad .derived-road-cell.player {
        background-color: #3b82f6;
      }
      #smallRoad .derived-road-cell.banker {
        background-color: #ef4444;
      }

      /* Cockroach Road: Slashes */
      #cockroachRoad .derived-road-cell {
        background: transparent;
        border-radius: 0;
        position: relative;
      }
      #cockroachRoad .derived-road-cell.player::before {
        /* Blue slash / */
        content: "";
        position: absolute;
        width: 6px;
        height: 2px;
        background: #3b82f6;
        top: 2.5px;
        left: 0.5px;
        transform: rotate(45deg);
        transform-origin: center;
        border-radius: 1px;
      }
      #cockroachRoad .derived-road-cell.banker::before {
        /* Red slash \ */
        content: "";
        position: absolute;
        width: 6px;
        height: 2px;
        background: #ef4444;
        top: 2.5px;
        left: 0.5px;
        transform: rotate(-45deg);
        transform-origin: center;
        border-radius: 1px;
      }

      #smallAndCockroachContainer {
        display: grid;
        grid-template-rows: 1fr 1fr;
        gap: 4px;
      }
    </style>
  </head>
  <body class="bg-black text-white min-h-screen max-w-5xl mx-auto">
    <!-- 상단 헤더 수정 -->
    <header class="fixed top-0 left-0 right-0 header-container z-50">
      <div class="flex justify-between items-center p-0.5 max-w-5xl mx-auto">
        <!-- 왼쪽 나가기 버튼 -->
        <button
          id="logout"
          class="golden-btn px-2 py-1 rounded-full text-xs font-semibold"
        >
          나가기
        </button>

        <!-- 중앙 빈 공간 -->
        <div class="flex-1"></div>

        <!-- 오른쪽 잔액과 총 베팅 정보 -->
        <div class="flex items-center gap-4">
          <span id="coinBalance" class="text-sm text-yellow-500 font-semibold"
            >잔액: 0원</span
          >
          <span
            id="totalBetAmount"
            class="text-sm text-orange-400 font-semibold"
            >총 베팅: 0원</span
          >
        </div>
      </div>
    </header>

    <main class="lg:flex lg:flex-col pt-6">
      <!-- 미니게임 컨테이너 추가 -->
      <div
        id="miniGameContainerWrapper"
        class="mb-4 px-1 lg:flex-shrink-0 mt-2"
      >
        <div id="miniGameContainer" class="w-full h-52 sm:h-64 md:h-72 lg:h-80
        xl:h-96 bg-green-700 bg-opacity-80 rounded-lg shadow-xl overflow-hidden
        mx-auto" /* PC에서 높이 증가 */ style="max-width: 1000px; border: 2px
        solid #b8860b" /* 최대 너비 확장 */ >
        <!-- Phaser 게임이 여기에 렌더링됩니다. -->
      </div>

      <!-- 타이머 (미니게임 아래로 이동) -->
      <div class="text-center lg:flex-shrink-0">
        <div
          id="timer"
          class="text-base font-semibold text-yellow-400 bg-black bg-opacity-50 inline-block px-3 py-1 rounded-lg border border-[#b8860b]"
        ></div>
      </div>
      <!-- 최근 게임 결과 섹션 (이동된 위치) -->
      <div class="mb-2 lg:mb-1 lg:flex-shrink-0">
        <div class="bg-gray-900 rounded-lg border border-[#b8860b] p-3">
          <!-- 통계와 예측 버튼 -->
          <div class="flex justify-between items-start mb-2">
            <!-- 왼쪽 통계 -->
            <div class="flex items-center gap-3 text-sm">
              <span class="text-blue-400 font-semibold"
                >P: <span id="playerCount">0</span></span
              >
              <span class="text-red-400 font-semibold"
                >B: <span id="bankerCount">0</span></span
              >
              <span class="text-green-400 font-semibold"
                >T: <span id="tieCount">0</span></span
              >
            </div>

            <!-- 오른쪽 예측 버튼 -->
            <div class="flex gap-1">
              <button
                id="predictPlayer"
                class="px-5 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700 transition-colors min-w-[32px]"
              >
                P
              </button>
              <button
                id="predictBanker"
                class="px-5 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-700 transition-colors min-w-[32px]"
              >
                B
              </button>
              <button
                id="predictTie"
                class="px-5 py-1 bg-green-600 text-white text-xs rounded hover:bg-green-700 transition-colors min-w-[32px]"
              >
                T
              </button>
            </div>
          </div>

          <!-- 게임 결과 격자 -->
          <div id="scoreboardsContainer">
            <div
              id="recentResults"
              class="custom-scrollbar bg-gray-800 border border-gray-600 rounded"
            >
              <!-- 최근 결과가 여기에 추가됩니다 -->
            </div>
            <div id="derivedRoadsContainer">
              <div id="bigEyeRoad" class="derived-road-grid">
                <!-- Big Eye Road here -->
              </div>
              <div id="smallAndCockroachContainer">
                <div id="smallRoad" class="derived-road-grid">
                  <!-- Small Road here -->
                </div>
                <div id="cockroachRoad" class="derived-road-grid">
                  <!-- Cockroach Road here -->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- 베팅 선택 영역 -->
      <div class="mt-2 lg:flex-1 lg:flex lg:flex-col lg:justify-center">
        <div
          class="text-center text-lg font-bold text-yellow-500"
          style="text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5)"
        >
          <!-- 베팅 타이틀 제거 또는 변경 -->
        </div>
        <div class="betting-area">
          <button
            data-choice="player_pair"
            class="bet-option player-pair choice-button"
          >
            <span class="title">P PAIR</span>
            <span class="odds">11:1</span>
            <div class="bet-stats-container" id="player_pairStats">
              <!-- 페어 베팅 통계 (금액, 인원) -->
              <div class="stats-details">
                <span class="total-bet">₩0</span>
                <span class="my-bet-amount text-xs text-amber-300"></span>
                <!-- 내 베팅액 표시 추가 -->
                <span class="bettor-count"><i class="fas fa-users"></i> 0</span>
              </div>
            </div>
          </button>

          <button data-choice="player" class="bet-option player choice-button">
            <span class="title">PLAYER</span>
            <span class="odds">1:1</span>
            <div class="bet-stats-container" id="playerStats">
              <!-- <div class="percentage-circle">0%</div> -->
              <!-- 퍼센티지 표시 제거 -->
              <div class="stats-details">
                <span class="total-bet">₩0</span>
                <span class="my-bet-amount text-xs text-amber-300"></span>
                <!-- 내 베팅액 표시 추가 -->
                <span class="bettor-count"><i class="fas fa-users"></i> 0</span>
              </div>
            </div>
          </button>

          <button data-choice="tie" class="bet-option tie choice-button">
            <span class="title">TIE</span>
            <span class="odds">8:1</span>
            <div class="bet-stats-container" id="tieStats">
              <!-- <div class="percentage-circle">0%</div> -->
              <!-- 퍼센티지 표시 제거 -->
              <div class="stats-details">
                <span class="total-bet">₩0</span>
                <span class="my-bet-amount text-xs text-amber-300"></span>
                <!-- 내 베팅액 표시 추가 -->
                <span class="bettor-count"><i class="fas fa-users"></i> 0</span>
              </div>
            </div>
          </button>

          <button data-choice="banker" class="bet-option banker choice-button">
            <span class="title">BANKER</span>
            <span class="odds">0.95:1</span>
            <div class="bet-stats-container" id="bankerStats">
              <!-- <div class="percentage-circle">0%</div> -->
              <!-- 퍼센티지 표시 제거 -->
              <div class="stats-details">
                <span class="total-bet">₩0</span>
                <span class="my-bet-amount text-xs text-amber-300"></span>
                <!-- 내 베팅액 표시 추가 -->
                <span class="bettor-count"><i class="fas fa-users"></i> 0</span>
              </div>
            </div>
          </button>

          <button
            data-choice="banker_pair"
            class="bet-option banker-pair choice-button"
          >
            <span class="title">B PAIR</span>
            <span class="odds">11:1</span>
            <div class="bet-stats-container" id="banker_pairStats">
              <!-- 페어 베팅 통계 (금액, 인원) -->
              <div class="stats-details">
                <span class="total-bet">₩0</span>
                <span class="my-bet-amount text-xs text-amber-300"></span>
                <!-- 내 베팅액 표시 추가 -->
                <span class="bettor-count"><i class="fas fa-users"></i> 0</span>
              </div>
            </div>
          </button>
        </div>
      </div>

      <!-- 금액 선택 영역 - 동그라미 스타일 -->
      <div class="mb-2 lg:flex-shrink-0">
        <div
          class="flex justify-center items-center gap-2 sm:gap-3 md:gap-4 px-4"
        >
          <!-- 반응형 간격 -->
          <button data-amount="1000" class="amount-button coin-button relative">
            1K
          </button>
          <button data-amount="5000" class="amount-button coin-button relative">
            5K
          </button>
          <button
            data-amount="10000"
            class="amount-button coin-button relative"
          >
            10K
          </button>
          <button
            data-amount="25000"
            class="amount-button coin-button relative"
          >
            25K
          </button>
          <button
            data-amount="50000"
            class="amount-button coin-button relative"
          >
            50K
          </button>
          <button
            data-amount="100000"
            class="amount-button coin-button relative"
          >
            100K
          </button>
          <button
            data-amount="500000"
            class="amount-button coin-button relative"
          >
            500K
          </button>
          <button
            id="undoBetButton"
            class="golden-btn px-4 py-2 rounded-lg text-sm font-semibold ml-2"
          >
            <i class="fas fa-undo"></i>
          </button>
        </div>
      </div>

      <!-- 하단 버튼 레이아웃 새로 구성 -->
      <div
        class="grid grid-cols-3 gap-1.5 sm:gap-2 md:gap-3 mt-2 lg:mt-1 mb-2 lg:mb-1 px-2 sm:px-4 lg:flex-shrink-0"
      >
        <!-- 반응형 간격과 패딩 추가 -->
        <button
          id="showChargeExchange"
          class="golden-btn py-2 rounded-lg text-xs font-bold shadow-lg"
        >
          충전 & 환전
        </button>
        <button
          id="showHistory"
          class="golden-btn py-2 rounded-lg text-xs font-bold shadow-lg"
        >
          베팅 기록
        </button>
        <button
          id="showMyInfo"
          class="golden-btn py-2 rounded-lg text-xs font-bold shadow-lg"
        >
          내 정보
        </button>
      </div>

      <!-- 베팅 기록 모달 (최근 게임 결과 섹션이 이 앞으로 이동되었으므로, 여기서는 삭제됨) -->
      <div
        id="historyModal"
        class="fixed inset-0 bg-black bg-opacity-80 z-50 hidden backdrop-blur-sm"
      >
        <div
          class="fixed inset-x-0 bottom-0 bg-gradient-to-b from-[#2a2a2a] to-[#1a1a1a] rounded-t-2xl max-h-[80vh] border-t border-[#b8860b] flex flex-col"
        >
          <!-- 고정 헤더 -->
          <div
            class="flex-shrink-0 bg-gradient-to-b from-[#2a2a2a] to-[#1a1a1a] p-4 border-b border-[#b8860b] rounded-t-2xl"
          >
            <div class="flex justify-between items-center">
              <h2
                class="text-xl font-bold text-yellow-500"
                style="text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5)"
              >
                나의 베팅 기록
              </h2>
              <button
                id="closeHistory"
                class="text-yellow-500 hover:text-yellow-400 transition-colors"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-6 w-6"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            </div>
          </div>

          <!-- 스크롤 가능한 컨텐츠 영역 -->
          <div class="flex-1 overflow-y-auto custom-scrollbar">
            <div id="bettingHistory" class="p-4 space-y-2">
              <!-- 베팅 기록이 여기에 추가됩니다 -->
            </div>
          </div>
        </div>
      </div>

      <!-- 충전&환전 통합 모달 -->
      <div
        id="chargeExchangeModal"
        class="fixed inset-0 bg-black bg-opacity-80 z-50 hidden backdrop-blur-sm"
      >
        <div
          class="fixed inset-x-0 bottom-0 bg-gradient-to-b from-[#2a2a2a] to-[#1a1a1a] rounded-t-2xl max-h-[85vh] overflow-y-auto border-t border-[#b8860b]"
        >
          <div
            class="sticky top-0 bg-gradient-to-b from-[#2a2a2a] to-[#1a1a1a] p-4 border-b border-[#b8860b]"
          >
            <div class="flex justify-between items-center mb-4">
              <h2
                class="text-xl font-bold text-yellow-500"
                style="text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5)"
              >
                충전 & 환전
              </h2>
              <button
                id="closeChargeExchange"
                class="text-yellow-500 hover:text-yellow-400"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-6 w-6"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            </div>

            <!-- 탭 메뉴 -->
            <div class="flex space-x-1 bg-black bg-opacity-50 rounded-lg p-1">
              <button
                id="chargeTab"
                class="flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors golden-btn"
              >
                충전
              </button>
              <button
                id="exchangeTab"
                class="flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors text-gray-400 hover:text-yellow-500"
              >
                환전
              </button>
              <button
                id="historyTab"
                class="flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors text-gray-400 hover:text-yellow-500"
              >
                내역
              </button>
              <button
                id="transferTab"
                class="flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors text-gray-400 hover:text-yellow-500"
              >
                뽀찌
              </button>
            </div>
          </div>

          <!-- 충전 신청 탭 내용 -->
          <div id="chargeContent" class="p-4">
            <div class="space-y-4">
              <div>
                <label class="block text-sm font-medium text-yellow-500 mb-2"
                  >충전 신청 금액</label
                >
                <div class="flex gap-2 mb-2">
                  <input
                    type="number"
                    id="depositAmount"
                    min="10000"
                    placeholder="최소 10,000원"
                    class="w-full bg-black bg-opacity-50 border border-[#b8860b] rounded-lg px-4 py-3 text-white focus:border-yellow-500 focus:ring-2 focus:ring-yellow-500"
                  />
                </div>
                <div class="flex flex-wrap justify-center gap-2">
                  <button
                    data-deposit-amount="10000"
                    class="deposit-amount-btn golden-btn px-4 py-1.5 rounded-md text-xs"
                  >
                    1만원
                  </button>
                  <button
                    data-deposit-amount="50000"
                    class="deposit-amount-btn golden-btn px-4 py-1.5 rounded-md text-xs"
                  >
                    5만원
                  </button>
                  <button
                    data-deposit-amount="100000"
                    class="deposit-amount-btn golden-btn px-4 py-1.5 rounded-md text-xs"
                  >
                    10만원
                  </button>
                  <button
                    data-deposit-amount="500000"
                    class="deposit-amount-btn golden-btn px-4 py-1.5 rounded-md text-xs"
                  >
                    50만원
                  </button>
                  <button
                    data-deposit-amount="1000000"
                    class="deposit-amount-btn golden-btn px-4 py-1.5 rounded-md text-xs"
                  >
                    100만원
                  </button>
                </div>
              </div>

              <button
                id="submitDeposit"
                class="w-full golden-btn py-3 rounded-lg text-lg font-bold shadow-lg"
              >
                충전 신청하기
              </button>
            </div>
          </div>

          <!-- 환전 신청 탭 내용 -->
          <div id="exchangeContent" class="p-4 hidden">
            <div class="text-sm text-gray-400 space-y-2">
              <div
                class="flex justify-between items-center p-3 bg-black bg-opacity-50 rounded-lg border border-[#b8860b]"
              >
                <span>현재 보유 금액:</span>
                <span
                  class="text-yellow-500 font-bold text-lg"
                  id="modalCoinBalance2"
                  >0원</span
                >
              </div>
              <div>
                * 수수료: <span class="text-yellow-500">환전액의 10%</span>
              </div>
              <div>* 최소 환전 가능 금액: 5,000원</div>
              <div>
                * 롤링 조건:
                <span class="text-yellow-500">충전액의 150%</span> 베팅 완료 시
                전액 환전 가능
              </div>
              <div>* 새로 충전할 때마다 롤링이 초기화됩니다</div>
              <div>
                * 현재 환전 가능 금액:
                <span class="text-green-400 font-bold" id="maxExchangeAmount"
                  >0원</span
                >
              </div>
              <div
                id="rollingInfo"
                class="mt-2 p-3 bg-black bg-opacity-50 rounded-lg border border-[#b8860b] space-y-1"
              >
                <div>
                  롤링 달성률:
                  <span class="text-yellow-500" id="rollingProgressText"
                    >0%</span
                  >
                </div>
                <div class="w-full bg-gray-700 rounded-full h-2.5">
                  <div
                    id="rollingProgressBar"
                    class="bg-yellow-500 h-2.5 rounded-full"
                    style="width: 0%"
                  ></div>
                </div>
                <div class="text-xs text-right text-gray-400">
                  <span id="rollingWageredText">0</span> /
                  <span id="rollingRequirementText">0</span>
                </div>
              </div>
            </div>
            <div class="space-y-4 mt-4">
              <div>
                <label class="block text-sm font-medium text-yellow-500 mb-2"
                  >환전 신청 금액</label
                >
                <div class="flex gap-2">
                  <input
                    type="number"
                    id="exchangeAmount"
                    min="5000"
                    class="w-full bg-black bg-opacity-50 border border-[#b8860b] rounded-lg px-4 py-3 text-white focus:border-yellow-500 focus:ring-2 focus:ring-yellow-500"
                  />
                  <button
                    id="maxAmount"
                    class="golden-btn px-4 rounded-lg text-sm font-bold"
                  >
                    최대
                  </button>
                </div>
              </div>
              <div
                id="exchangePreview"
                class="text-sm space-y-2 p-3 bg-black bg-opacity-50 rounded-lg border border-[#b8860b] hidden"
              >
                <div>
                  신청 금액:
                  <span id="requestAmount" class="text-yellow-500">0원</span>
                </div>
                <div>
                  수수료: <span id="feeAmount" class="text-red-400">0원</span>
                </div>
                <div>
                  실수령액:
                  <span id="actualAmount" class="text-yellow-500">0원</span>
                </div>
              </div>
              <button
                id="submitExchange"
                class="w-full golden-btn py-3 rounded-lg text-lg font-bold shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
              >
                환전 신청하기
              </button>
            </div>
          </div>

          <!-- 내역 조회 탭 내용 -->
          <div id="historyContent" class="p-4 hidden">
            <div id="exchangeHistoryList" class="space-y-3">
              <!-- 환전 내역이 여기에 표시됩니다 -->
            </div>
          </div>

          <!-- 뽀찌 탭 내용 -->
          <div id="transferContent" class="p-4 hidden">
            <!-- 상단 탭 선택 -->
            <div
              class="flex space-x-2 mb-4 bg-black bg-opacity-30 rounded-lg p-1"
            >
              <button
                id="sendMoneyBtn"
                class="flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors golden-btn"
              >
                송금하기
              </button>
              <button
                id="requestMoneyBtn"
                class="flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors text-gray-400 hover:text-yellow-500"
              >
                요청하기
              </button>
              <button
                id="transferHistoryBtn"
                class="flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors text-gray-400 hover:text-yellow-500"
              >
                내역보기
              </button>
            </div>

            <!-- 송금하기 섹션 -->
            <div id="sendMoneySection" class="space-y-4">
              <div
                class="bg-black bg-opacity-50 p-3 rounded-lg border border-[#b8860b]"
              >
                <div class="flex justify-between items-center">
                  <span class="text-gray-400">현재 보유금액:</span>
                  <span
                    class="text-yellow-500 font-bold text-lg"
                    id="transferBalance"
                    >0원</span
                  >
                </div>
              </div>

              <!-- 사용자 검색 -->
              <div>
                <label class="block text-sm font-medium text-yellow-500 mb-2"
                  >사용자 검색</label
                >
                <input
                  type="text"
                  id="userSearchInput"
                  placeholder="사용자명을 입력하세요"
                  class="w-full bg-black bg-opacity-50 border border-[#b8860b] rounded-lg px-4 py-2 text-white focus:border-yellow-500 focus:ring-2 focus:ring-yellow-500"
                />
              </div>

              <!-- 사용자 목록 -->
              <div
                class="bg-black bg-opacity-50 p-3 rounded-lg border border-[#b8860b] max-h-60 overflow-y-auto custom-scrollbar"
              >
                <div id="usersList" class="space-y-2">
                  <!-- 사용자 목록이 여기에 표시됩니다 -->
                </div>
              </div>

              <!-- 송금 금액 입력 -->
              <div id="sendMoneyForm" class="hidden space-y-4">
                <div class="bg-black bg-opacity-30 p-3 rounded-lg">
                  <span class="text-sm text-gray-400">받는 사람: </span>
                  <span
                    id="selectedUserName"
                    class="text-yellow-500 font-bold"
                  ></span>
                </div>

                <div>
                  <label class="block text-sm font-medium text-yellow-500 mb-2"
                    >송금 금액</label
                  >
                  <input
                    type="number"
                    id="sendAmount"
                    min="1000"
                    placeholder="최소 1,000원"
                    class="w-full bg-black bg-opacity-50 border border-[#b8860b] rounded-lg px-4 py-3 text-white focus:border-yellow-500 focus:ring-2 focus:ring-yellow-500"
                  />
                </div>

                <div class="text-sm text-gray-400">
                  * 송금 수수료: <span class="text-yellow-500">5%</span>
                </div>

                <div
                  id="sendPreview"
                  class="hidden p-3 bg-black bg-opacity-50 rounded-lg border border-[#b8860b] space-y-1"
                >
                  <div>
                    송금액:
                    <span id="sendAmountPreview" class="text-yellow-500"
                      >0원</span
                    >
                  </div>
                  <div>
                    수수료:
                    <span id="sendFeePreview" class="text-red-400">0원</span>
                  </div>
                  <div>
                    총 차감액:
                    <span id="sendTotalPreview" class="text-yellow-500"
                      >0원</span
                    >
                  </div>
                </div>

                <button
                  id="confirmSendButton"
                  class="w-full golden-btn py-3 rounded-lg text-lg font-bold shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                  disabled
                >
                  송금하기
                </button>
              </div>
            </div>

            <!-- 요청하기 섹션 -->
            <div id="requestMoneySection" class="hidden space-y-4">
              <!-- 사용자 검색 -->
              <div>
                <label class="block text-sm font-medium text-yellow-500 mb-2"
                  >사용자 검색</label
                >
                <input
                  type="text"
                  id="requestUserSearchInput"
                  placeholder="사용자명을 입력하세요"
                  class="w-full bg-black bg-opacity-50 border border-[#b8860b] rounded-lg px-4 py-2 text-white focus:border-yellow-500 focus:ring-2 focus:ring-yellow-500"
                />
              </div>

              <!-- 사용자 목록 -->
              <div
                class="bg-black bg-opacity-50 p-3 rounded-lg border border-[#b8860b] max-h-60 overflow-y-auto custom-scrollbar"
              >
                <div id="requestUsersList" class="space-y-2">
                  <!-- 사용자 목록이 여기에 표시됩니다 -->
                </div>
              </div>

              <!-- 요청 금액 입력 -->
              <div id="requestMoneyForm" class="hidden space-y-4">
                <div class="bg-black bg-opacity-30 p-3 rounded-lg">
                  <span class="text-sm text-gray-400">요청 대상: </span>
                  <span
                    id="requestSelectedUserName"
                    class="text-yellow-500 font-bold"
                  ></span>
                </div>

                <div>
                  <label class="block text-sm font-medium text-yellow-500 mb-2"
                    >요청 금액</label
                  >
                  <input
                    type="number"
                    id="requestAmount"
                    min="1000"
                    placeholder="최소 1,000원"
                    class="w-full bg-black bg-opacity-50 border border-[#b8860b] rounded-lg px-4 py-3 text-white focus:border-yellow-500 focus:ring-2 focus:ring-yellow-500"
                  />
                </div>

                <div>
                  <label class="block text-sm font-medium text-yellow-500 mb-2"
                    >요청 메시지 (선택)</label
                  >
                  <textarea
                    id="requestMessage"
                    rows="3"
                    placeholder="요청 메시지를 입력하세요"
                    class="w-full bg-black bg-opacity-50 border border-[#b8860b] rounded-lg px-4 py-2 text-white focus:border-yellow-500 focus:ring-2 focus:ring-yellow-500"
                  ></textarea>
                </div>

                <button
                  id="confirmRequestButton"
                  class="w-full golden-btn py-3 rounded-lg text-lg font-bold shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                  disabled
                >
                  요청하기
                </button>
              </div>
            </div>

            <!-- 내역보기 섹션 -->
            <div id="transferHistorySection" class="hidden space-y-4">
              <!-- 보낸 요청 / 받은 요청 목록 -->
              <div class="space-y-4">
                <div>
                  <h3 class="text-lg font-bold text-yellow-500 mb-3">
                    받은 요청
                  </h3>
                  <div id="receivedRequestsList" class="space-y-2">
                    <!-- 받은 요청 목록이 여기에 표시됩니다 -->
                  </div>
                </div>

                <div>
                  <h3 class="text-lg font-bold text-yellow-500 mb-3">
                    송금 내역
                  </h3>
                  <div id="transferHistoryList" class="space-y-2">
                    <!-- 송금 내역이 여기에 표시됩니다 -->
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 내 정보 모달 -->
      <div
        id="myInfoModal"
        class="fixed inset-0 bg-black bg-opacity-80 z-50 hidden backdrop-blur-sm"
      >
        <div
          class="fixed inset-x-0 bottom-0 bg-gradient-to-b from-[#2a2a2a] to-[#1a1a1a] rounded-t-2xl max-h-[85vh] border-t border-[#b8860b] flex flex-col"
        >
          <!-- 고정 헤더 -->
          <div
            class="flex-shrink-0 bg-gradient-to-b from-[#2a2a2a] to-[#1a1a1a] p-4 border-b border-[#b8860b] rounded-t-2xl"
          >
            <div class="flex justify-between items-center mb-4">
              <h2
                class="text-xl font-bold text-yellow-500"
                style="text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5)"
              >
                내 정보
              </h2>
              <button
                id="closeMyInfo"
                class="text-yellow-500 hover:text-yellow-400"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-6 w-6"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            </div>

            <!-- 탭 메뉴 -->
            <div class="flex space-x-1 bg-black bg-opacity-50 rounded-lg p-1">
              <button
                id="overviewTab"
                class="flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors golden-btn"
              >
                개요
              </button>
              <button
                id="bettingTab"
                class="flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors text-gray-400 hover:text-yellow-500"
              >
                분석
              </button>
              <button
                id="financialTab"
                class="flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors text-gray-400 hover:text-yellow-500"
              >
                재정
              </button>
            </div>
          </div>

          <!-- 스크롤 가능한 컨텐츠 영역 -->
          <div class="flex-1 overflow-y-auto custom-scrollbar">
            <!-- 개요 탭 -->
            <div id="overviewContent" class="p-4 space-y-4">
              <!-- 게임 통계 요약 -->
              <div
                class="bg-black bg-opacity-50 p-4 rounded-lg border border-[#b8860b]"
              >
                <h3 class="text-lg font-bold text-yellow-500 mb-3">
                  게임 통계
                </h3>
                <div class="grid grid-cols-2 gap-3 mb-4">
                  <div
                    class="bg-black bg-opacity-30 p-3 rounded-lg text-center"
                  >
                    <div
                      class="text-2xl font-bold text-green-400"
                      id="userWins"
                    >
                      0
                    </div>
                    <div class="text-xs text-gray-400">승리</div>
                  </div>
                  <div
                    class="bg-black bg-opacity-30 p-3 rounded-lg text-center"
                  >
                    <div class="text-2xl font-bold text-red-400" id="userLoses">
                      0
                    </div>
                    <div class="text-xs text-gray-400">패배</div>
                  </div>
                  <div
                    class="bg-black bg-opacity-30 p-3 rounded-lg text-center"
                  >
                    <div
                      class="text-lg font-bold text-yellow-500"
                      id="userWinRate"
                    >
                      0%
                    </div>
                    <div class="text-xs text-gray-400">승률</div>
                  </div>
                  <div
                    class="bg-black bg-opacity-30 p-3 rounded-lg text-center"
                  >
                    <div
                      class="text-lg font-bold text-blue-400"
                      id="totalGames"
                    >
                      0
                    </div>
                    <div class="text-xs text-gray-400">총 게임</div>
                  </div>
                </div>

                <!-- 베팅 손익 요약 -->
                <div class="bg-black bg-opacity-30 p-3 rounded-lg">
                  <div class="flex justify-between items-center">
                    <span class="text-gray-400 font-medium">베팅 순손익:</span>
                    <span class="font-bold text-lg" id="gameStatsBettingProfit"
                      >0원</span
                    >
                  </div>
                  <div class="text-xs text-gray-500 text-center mt-1">
                    * 베팅으로 인한 순수익/손실
                  </div>
                </div>
              </div>

              <!-- 전체 손익 요약 -->
              <div
                class="bg-black bg-opacity-50 p-4 rounded-lg border border-[#b8860b]"
              >
                <h3 class="text-lg font-bold text-yellow-500 mb-3">
                  전체 손익
                </h3>
                <div class="space-y-3">
                  <div class="flex justify-between items-center">
                    <span class="text-gray-400">현재 잔액:</span>
                    <span
                      class="text-yellow-500 font-bold text-lg"
                      id="currentBalance"
                      >0원</span
                    >
                  </div>
                  <div class="flex justify-between items-center">
                    <span class="text-gray-400">총 손익:</span>
                    <span class="font-bold text-lg" id="overallProfit"
                      >0원</span
                    >
                  </div>
                  <div class="text-xs text-gray-500 text-center">
                    * 총 손익 = 현재 잔액 + 총 환전액 - 총 충전액
                  </div>
                </div>
              </div>
            </div>

            <!-- 베팅 분석 탭 -->
            <div id="bettingContent" class="p-4 space-y-4 hidden">
              <!-- 베팅 통계 -->
              <div
                class="bg-black bg-opacity-50 p-4 rounded-lg border border-[#b8860b]"
              >
                <h3 class="text-lg font-bold text-yellow-500 mb-3">
                  베팅 통계
                </h3>
                <div class="space-y-2">
                  <div class="flex justify-between">
                    <span class="text-gray-400">총 베팅 금액:</span>
                    <span
                      class="text-yellow-500 font-bold"
                      id="modalTotalBetAmount"
                      >0원</span
                    >
                  </div>
                  <div class="flex justify-between">
                    <span class="text-gray-400">총 수익 금액:</span>
                    <span
                      class="text-green-400 font-bold"
                      id="modalTotalWinAmount"
                      >0원</span
                    >
                  </div>
                  <div class="flex justify-between">
                    <span class="text-gray-400">베팅 손익:</span>
                    <span class="font-bold" id="modalBettingProfit">0원</span>
                  </div>
                  <div class="flex justify-between">
                    <span class="text-gray-400">평균 베팅액:</span>
                    <span
                      class="text-blue-400 font-bold"
                      id="modalAverageBetAmount"
                      >0원</span
                    >
                  </div>
                </div>
                <div
                  class="mt-3 p-2 bg-black bg-opacity-30 rounded-lg border border-blue-500"
                >
                  <div class="text-xs text-gray-400 text-center">
                    💡 총 베팅 금액은 실제로 베팅한 금액 100%를 표시합니다
                  </div>
                </div>
              </div>

              <!-- 베팅 선호도 -->
              <div
                class="bg-black bg-opacity-50 p-4 rounded-lg border border-[#b8860b]"
              >
                <h3 class="text-lg font-bold text-yellow-500 mb-3">
                  베팅 선호도
                </h3>
                <div class="space-y-2" id="choicePreferences">
                  <!-- 선호도 차트가 여기에 표시됩니다 -->
                </div>
                <div
                  class="mt-3 p-2 bg-black bg-opacity-30 rounded text-center"
                >
                  <span class="text-gray-400 text-sm"
                    >가장 선호하는 베팅:
                  </span>
                  <span class="text-yellow-500 font-bold" id="favoriteChoice"
                    >-</span
                  >
                </div>
              </div>

              <!-- 롤링 정보 -->
              <div
                class="bg-black bg-opacity-50 p-4 rounded-lg border border-[#b8860b]"
              >
                <h3 class="text-lg font-bold text-yellow-500 mb-3">
                  롤링 현황
                </h3>
                <div class="space-y-3">
                  <div class="flex justify-between">
                    <span class="text-gray-400">롤링 달성률:</span>
                    <span
                      class="text-yellow-500 font-bold"
                      id="rollingProgressTextInfo"
                      >0%</span
                    >
                  </div>
                  <div class="w-full bg-gray-700 rounded-full h-2.5">
                    <div
                      id="rollingProgressBarInfo"
                      class="bg-yellow-500 h-2.5 rounded-full"
                      style="width: 0%"
                    ></div>
                  </div>
                  <div class="flex justify-between text-sm">
                    <span class="text-gray-400"
                      >현재 베팅액:
                      <span id="rollingWageredAmount">0원</span></span
                    >
                    <span class="text-gray-400"
                      >목표 베팅액:
                      <span id="rollingRequiredAmount">0원</span></span
                    >
                  </div>
                  <div
                    class="mt-3 p-3 bg-black bg-opacity-30 rounded-lg border border-yellow-500"
                  >
                    <div class="text-xs text-gray-400 mb-1">
                      💡 롤링 시스템 안내
                    </div>
                    <div class="text-xs text-yellow-400">
                      • 충전액의 150% 베팅 완료 시 전액 환전 가능
                    </div>
                    <div class="text-xs text-yellow-400">
                      • 새로 충전할 때마다 롤링이 초기화됩니다
                    </div>
                    <div
                      class="text-xs text-green-400 mt-1"
                      id="rollingStatusText"
                    >
                      롤링 미달성
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- 재정 현황 탭 -->
            <div id="financialContent" class="p-4 space-y-4 hidden">
              <!-- 충전/환전 통계 -->
              <div
                class="bg-black bg-opacity-50 p-4 rounded-lg border border-[#b8860b]"
              >
                <h3 class="text-lg font-bold text-yellow-500 mb-3">
                  충전/환전 통계
                </h3>
                <div class="grid grid-cols-2 gap-4">
                  <div
                    class="bg-black bg-opacity-30 p-3 rounded-lg text-center"
                  >
                    <div
                      class="text-lg font-bold text-blue-400"
                      id="totalDeposited"
                    >
                      0원
                    </div>
                    <div class="text-xs text-gray-400">총 충전액</div>
                    <div class="text-xs text-gray-500 mt-1">
                      (<span id="depositCount">0</span>회)
                    </div>
                  </div>
                  <div
                    class="bg-black bg-opacity-30 p-3 rounded-lg text-center"
                  >
                    <div
                      class="text-lg font-bold text-orange-400"
                      id="totalExchanged"
                    >
                      0원
                    </div>
                    <div class="text-xs text-gray-400">총 환전액</div>
                    <div class="text-xs text-gray-500 mt-1">
                      (<span id="exchangeCount">0</span>회)
                    </div>
                  </div>
                </div>
              </div>

              <!-- 최근 충전 내역 -->
              <div
                class="bg-black bg-opacity-50 p-4 rounded-lg border border-[#b8860b]"
              >
                <h3 class="text-lg font-bold text-yellow-500 mb-3">
                  최근 충전 내역
                </h3>
                <div id="recentDeposits" class="space-y-2">
                  <!-- 최근 충전 내역이 여기에 표시됩니다 -->
                </div>
              </div>

              <!-- 최근 환전 내역 -->
              <div
                class="bg-black bg-opacity-50 p-4 rounded-lg border border-[#b8860b]"
              >
                <h3 class="text-lg font-bold text-yellow-500 mb-3">
                  최근 환전 내역
                </h3>
                <div id="recentExchanges" class="space-y-2">
                  <!-- 최근 환전 내역이 여기에 표시됩니다 -->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 승리 메시지 -->
      <div
        id="winMessage"
        class="fixed top-20 left-0 right-0 flex justify-center z-50 hidden pointer-events-none"
      >
        <div
          class="bg-gradient-to-r from-gray-800 to-gray-900 text-white px-6 py-4 rounded-xl shadow-2xl border border-green-500 backdrop-blur-sm transform transition-all duration-300 ease-out"
        >
          <div class="text-center">
            <div class="flex items-center justify-center space-x-2 mb-2">
              <div
                class="w-5 h-5 bg-green-500 rounded-full flex items-center justify-center"
              >
                <svg
                  class="w-3 h-3 text-white"
                  fill="currentColor"
                  viewBox="0 0 20 20"
                >
                  <path
                    fill-rule="evenodd"
                    d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                    clip-rule="evenodd"
                  ></path>
                </svg>
              </div>
              <h2 class="text-lg font-bold">이기셨습니다!</h2>
            </div>
            <p class="text-green-400 font-bold text-xl" id="winAmountDisplay">
              0원
            </p>
          </div>
        </div>
      </div>
    </main>

    <!-- 알림  -->
    <div
      id="notification"
      class="fixed top-20 left-4 right-4 bg-gradient-to-b from-[#2a2a2a] to-[#1a1a1a] text-yellow-500 p-4 rounded-lg shadow-lg hidden transform transition-transform duration-300 border border-[#b8860b]"
    >
      <p id="notificationMessage" class="text-center font-bold"></p>
    </div>

    <!-- 환전 신청 완료 모달 -->
    <div
      id="exchangeRequestModal"
      class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden"
    >
      <div
        class="bg-gradient-to-b from-[#2a2a2a] to-[#1a1a1a] rounded-xl p-6 max-w-md w-full mx-4 border-2 border-[#b8860b] shadow-2xl"
      >
        <div class="text-center">
          <div
            class="w-16 h-16 bg-green-500 rounded-full flex items-center justify-center mx-auto mb-4"
          >
            <svg
              class="w-8 h-8 text-white"
              fill="currentColor"
              viewBox="0 0 20 20"
            >
              <path
                fill-rule="evenodd"
                d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                clip-rule="evenodd"
              ></path>
            </svg>
          </div>
          <h2 class="text-2xl font-bold text-yellow-500 mb-2">
            환전 신청 완료
          </h2>
          <p class="text-white text-lg mb-4">
            환전이 신청되었습니다.<br />승인을 될 수도 있고, 안될 수도 있습니다.
          </p>
          <div
            class="bg-black bg-opacity-50 p-4 rounded-lg border border-[#b8860b] mb-4"
          >
            <div class="space-y-2 text-sm">
              <div class="flex justify-between">
                <span class="text-gray-400">신청 금액:</span>
                <span class="text-yellow-500 font-bold" id="modalRequestAmount"
                  >0원</span
                >
              </div>
              <div class="flex justify-between">
                <span class="text-gray-400">차감된 잔액:</span>
                <span class="text-red-400 font-bold" id="modalDeductedAmount"
                  >0원</span
                >
              </div>
              <div class="flex justify-between">
                <span class="text-gray-400">현재 잔액:</span>
                <span class="text-blue-400 font-bold" id="modalCurrentBalance"
                  >0원</span
                >
              </div>
            </div>
          </div>
          <button
            id="closeExchangeRequestModal"
            class="golden-btn py-3 px-6 rounded-lg text-lg font-bold"
          >
            확인
          </button>
        </div>
      </div>
    </div>

    <!-- 오디오 요소들 -->
    <audio id="bettingStartSound" src="sound.mp3" preload="auto"></audio>
    <audio id="bettingEndSound" src="endsound.mp3" preload="auto"></audio>

    <!-- 플로팅 채팅 UI -->
    <!-- 채팅 플로팅 버튼 (헤더 아래, 작은 크기) -->
    <div
      id="chatFloatingButton"
      class="fixed top-20 right-4 z-40 transition-all duration-300"
    >
      <button
        class="w-10 h-10 bg-gradient-to-r from-[#b8860b] to-[#daa520] rounded-full shadow-md hover:shadow-lg transform hover:scale-110 transition-all duration-300 flex items-center justify-center text-white bg-opacity-60 backdrop-blur-sm hover:bg-opacity-80"
      >
        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
          <path
            fill-rule="evenodd"
            d="M18 10c0 3.866-3.582 7-8 7a8.841 8.841 0 01-4.083-.98L2 17l1.338-3.123C2.493 12.767 2 11.434 2 10c0-3.866 3.582-7 8-7s8 3.134 8 7zM7 9H5v2h2V9zm8 0h-2v2h2V9zM9 9h2v2H9V9z"
            clip-rule="evenodd"
          ></path>
        </svg>
        <!-- 새 메시지 알림 뱃지 -->
        <div
          id="chatNotificationBadge"
          class="absolute -top-1 -right-1 w-4 h-4 bg-red-500 rounded-full text-xs text-white flex items-center justify-center font-bold hidden animate-pulse"
        >
          <span id="chatNotificationCount" class="text-xs">0</span>
        </div>
      </button>
    </div>

    <!-- 채팅 창 오버레이 -->
    <div
      id="chatOverlay"
      class="fixed inset-0 bg-black bg-opacity-30 z-40 hidden transition-opacity duration-300"
    ></div>

    <!-- 채팅 창 -->
    <div
      id="chatWindow"
      class="fixed bottom-0 left-0 right-0 h-96 bg-gradient-to-b from-[#2a2a2a] to-[#1a1a1a] border-t-2 border-[#b8860b] shadow-2xl z-50 hidden transform transition-all duration-300 backdrop-blur-md bg-opacity-95"
    >
      <div class="flex flex-col h-full">
        <!-- 채팅 헤더 -->
        <div
          class="flex items-center justify-between p-4 border-b border-[#b8860b] bg-gradient-to-r from-[#b8860b] to-[#daa520]"
        >
          <h3 class="text-white font-bold text-lg">실시간 채팅</h3>
          <button
            id="closeChatButton"
            class="text-white hover:text-gray-300 transition-colors"
          >
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
              <path
                fill-rule="evenodd"
                d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                clip-rule="evenodd"
              ></path>
            </svg>
          </button>
        </div>

        <!-- 채팅 메시지 영역 -->
        <div
          id="chatMessages"
          class="flex-1 p-4 overflow-y-auto custom-scrollbar space-y-3"
        >
          <!-- 채팅 메시지들이 여기에 동적으로 추가됩니다 -->
        </div>

        <!-- 채팅 입력 영역 -->
        <div class="p-4 border-t border-[#b8860b]">
          <div class="flex space-x-2">
            <button
              id="highlightChatButton"
              class="px-3 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-500 transition-all duration-300 font-bold text-sm"
              title="강조 모드 토글"
            >
              🔥
            </button>
            <input
              type="text"
              id="chatMessageInput"
              placeholder="메시지를 입력하세요..."
              maxlength="500"
              class="flex-1 px-3 py-2 bg-black bg-opacity-50 border border-[#b8860b] rounded-lg text-white placeholder-gray-400 focus:outline-none focus:border-yellow-500 text-sm"
            />
            <button
              id="sendChatButton"
              class="px-4 py-2 bg-gradient-to-r from-[#b8860b] to-[#daa520] text-white rounded-lg hover:from-[#daa520] hover:to-[#ffd700] transition-all duration-300 font-bold text-sm"
            >
              전송
            </button>
          </div>
          <div class="flex justify-between items-center text-xs mt-1">
            <div
              id="highlightModeIndicator"
              class="text-orange-400 font-bold hidden"
            >
              🔥 강조 모드 활성화
            </div>
            <div class="text-gray-400">
              <span id="chatCharCount">0</span>/500
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 메시지 알림 바 (관리자 & 강조 메시지 공용) -->
    <div
      id="adminMessageBar"
      class="fixed top-[72px] left-0 right-0 z-[60] transform -translate-y-full transition-all duration-500 ease-in-out hidden"
    >
      <div
        id="adminMessageBarContainer"
        class="bg-black bg-opacity-30 mx-4 rounded-lg backdrop-blur-md border border-white border-opacity-20"
      >
        <div class="flex items-center p-3">
          <div class="flex-shrink-0 mr-3">
            <svg
              id="adminMessageBarIcon"
              class="w-5 h-5 text-yellow-400"
              fill="currentColor"
              viewBox="0 0 20 20"
            >
              <path
                fill-rule="evenodd"
                d="M18 3a1 1 0 00-1.447-.894L8.763 6H5a3 3 0 000 6h.28l1.771 5.316A1 1 0 008 18h1a1 1 0 001-1v-4.382l6.553 3.276A1 1 0 0018 15V3z"
                clip-rule="evenodd"
              ></path>
            </svg>
          </div>
          <div class="flex-1 min-w-0">
            <div class="flex items-center justify-between">
              <span
                id="adminMessageBarSender"
                class="text-yellow-400 font-bold text-sm"
                >관리자</span
              >
              <span
                id="adminMessageBarTime"
                class="text-gray-400 text-xs"
              ></span>
            </div>
            <p
              id="adminMessageBarContent"
              class="text-white text-sm font-medium mt-1 break-words"
            ></p>
          </div>
          <button
            id="closeAdminMessageBar"
            class="flex-shrink-0 ml-3 text-gray-400 hover:text-white transition-colors"
          >
            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
              <path
                fill-rule="evenodd"
                d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                clip-rule="evenodd"
              ></path>
            </svg>
          </button>
        </div>
      </div>
    </div>

    <script>
      // 환전 내역 카드 생성 함수
      function createExchangeHistoryCard(exchange) {
        const card = document.createElement("div");
        card.className =
          "bg-black bg-opacity-50 p-4 rounded-lg border border-[#b8860b] shadow-lg";

        const statusClass = {
          pending: "text-yellow-500 font-bold",
          approved: "text-green-500 font-bold",
          rejected: "text-red-500 font-bold",
        }[exchange.status];

        const statusText = {
          pending: "대기중",
          approved: "승인됨",
          rejected: "거절됨",
        }[exchange.status];

        card.innerHTML = `
          <div class="flex justify-between items-center mb-3">
            <span class="text-sm text-gray-400">${new Date(
              exchange.createdAt
            ).toLocaleString()}</span>
            <span class="${statusClass} px-3 py-1 rounded-full bg-black bg-opacity-50 border border-[#b8860b]">
              ${statusText}
            </span>
          </div>
          <div class="grid grid-cols-2 gap-3 text-sm">
            <div class="bg-black bg-opacity-30 p-2 rounded-lg">
              신청 금액: <span class="text-yellow-500 font-bold">${
                exchange.requestAmount
              }원</span>
            </div>
            <div class="bg-black bg-opacity-30 p-2 rounded-lg">
              수수료: <span class="text-red-400 font-bold">${
                exchange.fee
              }원</span>
            </div>
            <div class="bg-black bg-opacity-30 p-2 rounded-lg">
              실수령액: <span class="text-yellow-500 font-bold">${
                exchange.actualAmount
              }원</span>
            </div>
            <div class="bg-black bg-opacity-30 p-2 rounded-lg">
              롤링 포인트: <span class="text-blue-400 font-bold">${(
                exchange.rollingPoint || 0
              ).toLocaleString()}원</span>
            </div>
          </div>
        `;
        return card;
      }

      window.addEventListener("DOMContentLoaded", async () => {
        const token = localStorage.getItem("token");

        // 토큰 유효성 검사 함수
        async function validateToken() {
          if (!token) {
            console.log("토큰이 없습니다. 로그인 페이지로 이동합니다.");
            window.location.href = "index.html";
            return false;
          }

          try {
            // fetch에 timeout 추가
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10초 타임아웃

            const res = await fetch(
              "https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/auth/user-info",
              {
                headers: { 
                  'Authorization': `Bearer ${token}`,
                  'Content-Type': 'application/json'
                },
                signal: controller.signal
              }
            );

            clearTimeout(timeoutId);

            if (res.status === 401 || res.status === 403) {
              console.log(
                "토큰이 만료되었거나 유효하지 않습니다. 로그인 페이지로 이동합니다."
              );
              localStorage.removeItem("token");
              window.location.href = "index.html";
              return false;
            }

            if (!res.ok) {
              console.warn("토큰 검증 응답 상태:", res.status);
              // 서버 오류의 경우 계속 진행
              return true;
            }

            return true;
          } catch (err) {
            console.error("토큰 검증 중 오류:", err);
            
            // AbortError (타임아웃)이나 네트워크 오류는 토큰 문제가 아닐 수 있으므로 계속 진행
            if (err.name === 'AbortError') {
              console.warn("토큰 검증 타임아웃 - 계속 진행");
              return true;
            }
            
            // 네트워크 오류의 경우에도 계속 진행
            return true;
          }
        }

        // 토큰 검증 후 계속 진행
        const isValidToken = await validateToken();
        if (!isValidToken) {
          return; // 토큰이 유효하지 않으면 함수 종료
        }

        let socket = io(
          "https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app"
        );

        // 페이지 가시성 상태 추적
        let isPageVisible = !document.hidden;
        let hasJoinedGame = false;

        // 게임 상태 저장을 위한 변수
        let gameSessionData = null;

        // 소켓 연결 후 인증만 수행 (자동 게임 시작 제거됨)
        socket.on("connect", () => {
          socket.emit("authenticate", token);
          // 세션 복원만 요청 (자동 게임 시작하지 않음)
          if (!hasJoinedGame && socket.connected) {
            console.log('소켓 연결됨 - 세션 복원 요청');
            socket.emit("join_baccarat_game", token);
            hasJoinedGame = true;
          } else {
            console.log('이미 게임에 참여했거나 소켓이 연결되지 않음');
          }
        });

        // 게임 상태 복원 이벤트 수신
        socket.on("game_state_restored", (data) => {
          gameSessionData = data;
          
          // 게임 상태 복원이 성공했으므로 참여 플래그 설정
          hasJoinedGame = true;
          
          console.log('게임 상태 수신:', data);
          
          // 재연결인지 확인
          if (data.isReconnecting) {
            console.log('재연결 감지됨 - 기존 게임 상태 유지');
            showNotification('재연결되었습니다.', 'success', 2000);
          }
          
          // 현재 게임 상태에 따른 UI 동기화
          if (data.gameState.currentGamePhase === 'betting' && data.bettingActive) {
            // 베팅 중이라면 베팅 UI 활성화 (중복 방지)
            if (!bettingActive) {
              bettingActive = true;
              
              if (data.bettingEndTime) {
                const remainingTime = new Date(data.bettingEndTime) - new Date();
                if (remainingTime > 0) {
                  // 기존 타이머가 실행 중이 아닐 때만 새 타이머 시작
                  if (!window.bettingTimerInterval) {
                    startTimer(new Date(data.bettingEndTime));
                  }
                  showNotification(`베팅 시간이 ${Math.ceil(remainingTime/1000)}초 남았습니다.`, 'info', 2000);
                }
              }
              
              // 베팅 버튼들 활성화
              enableBettingUI();
            } else {
              console.log('베팅이 이미 활성화되어 있어 중복 처리를 건너뜁니다.');
            }
          } else {
            // 베팅 중이 아니라면 베팅 UI 비활성화
            if (bettingActive) {
              bettingActive = false;
              // 기존 타이머 정리
              if (window.bettingTimerInterval) {
                clearInterval(window.bettingTimerInterval);
                window.bettingTimerInterval = null;
              }
            }
            disableBettingUI();
          }
          
          // 현재 베팅 정보 복원
          if (data.currentBets && Object.keys(data.currentBets).length > 0) {
            currentBets = data.currentBets;
            updateBettingDisplay();
            showNotification('기존 베팅이 복원되었습니다.', 'success', 2000);
          }
          
          // 베팅 통계 업데이트
          if (data.bettingStats) {
            updateBettingStats(data.bettingStats);
          }
          
          // 사용자 잔액 업데이트
          if (data.userBalance !== undefined) {
            updateBalance(data.userBalance);
          }
          
          // 관리자 자동 게임 상태 표시
          if (data.adminAutoGameActive) {
            showNotification('관리자 자동 게임이 진행 중입니다.', 'info', 2000);
          }
          
          // 백그라운드 게임 상태 표시
          if (data.backgroundGameActive) {
            showNotification('백그라운드 게임이 진행 중입니다.', 'info', 2000);
          }
        });

        // 소켓 연결 해제 시 상태 저장
        socket.on("disconnect", () => {
          hasJoinedGame = false;
          console.log('소켓 연결 해제');
        });

        // 알림 표시 함수
        function showNotification(message, type = 'info', duration = 3000) {
          const notification = document.createElement('div');
          notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg transform transition-all duration-300 translate-x-full`;
          
          const colors = {
            info: 'bg-blue-600 text-white',
            success: 'bg-green-600 text-white', 
            warning: 'bg-yellow-600 text-black',
            error: 'bg-red-600 text-white'
          };
          
          notification.className += ` ${colors[type] || colors.info}`;
          notification.textContent = message;
          
          document.body.appendChild(notification);
          
          // 애니메이션으로 나타내기
          setTimeout(() => {
            notification.classList.remove('translate-x-full');
          }, 100);
          
          // 지정된 시간 후 제거
          setTimeout(() => {
            notification.classList.add('translate-x-full');
            setTimeout(() => {
              if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
              }
            }, 300);
          }, duration);
        }
        
        // 베팅 UI 활성화 함수
        function enableBettingUI() {
          const choiceButtons = document.querySelectorAll('.choice-button');
          const coinButtons = document.querySelectorAll('.coin-button');
          
          choiceButtons.forEach(button => {
            button.disabled = false;
            button.classList.remove('opacity-50', 'cursor-not-allowed');
          });
          
          coinButtons.forEach(button => {
            button.disabled = false;
            button.classList.remove('opacity-50', 'cursor-not-allowed');
          });
          
          // 타이머 요소에 베팅 상태 표시
          const timerEl = document.getElementById("timer");
          if (timerEl && timerEl.textContent === "") {
            timerEl.textContent = "베팅 진행 중";
            timerEl.className = "text-base font-semibold text-yellow-400";
          }
        }
        
        // 베팅 UI 비활성화 함수
        function disableBettingUI() {
          const choiceButtons = document.querySelectorAll('.choice-button');
          const coinButtons = document.querySelectorAll('.coin-button');
          
          choiceButtons.forEach(button => {
            button.disabled = true;
            button.classList.add('opacity-50', 'cursor-not-allowed');
          });
          
          coinButtons.forEach(button => {
            button.disabled = true;
            button.classList.add('opacity-50', 'cursor-not-allowed');
          });
        }
        
        // 베팅 디스플레이 업데이트 함수
        function updateBettingDisplay() {
          for (const [choice, amount] of Object.entries(currentBets)) {
            const betDisplay = document.getElementById(`${choice}BetAmount`);
            if (betDisplay) {
              betDisplay.textContent = amount.toLocaleString();
              betDisplay.parentElement.style.display = amount > 0 ? 'block' : 'none';
            }
          }
        }
        
        // 예약 종료 상태 표시 함수 제거됨 - 관리자만 게임 제어 가능
        
        // 잔액 업데이트 함수
        function updateBalance(balance) {
          const balanceElements = document.querySelectorAll('.balance-display');
          balanceElements.forEach(element => {
            element.textContent = balance.toLocaleString();
          });
          
          // 잔액 표시 UI 업데이트
          const coinBalanceEl = document.getElementById("coinBalance");
          if (coinBalanceEl) {
            coinBalanceEl.textContent = `잔액: ${balance.toLocaleString()}원`;
          }
        }
        
        // 베팅 통계 업데이트 함수
        function updateBettingStats(stats) {
          // 각 선택지별 통계 업데이트
          for (const [choice, data] of Object.entries(stats)) {
            const countEl = document.getElementById(`${choice}Count`);
            const totalEl = document.getElementById(`${choice}Total`);
            
            if (countEl) countEl.textContent = data.count || 0;
            if (totalEl) totalEl.textContent = (data.total || 0).toLocaleString();
          }
        }

        // 실제 페이지 나가기만 처리 (새로고침/탭 전환은 무시)
        let isRealPageUnload = false;
        
        // 실제 페이지 나가기 감지 (브라우저 닫기, 다른 사이트 이동) - 자동 게임 시작 제거됨
        window.addEventListener("beforeunload", (e) => {
          // 실제 페이지 나가기인지 확인
          const navigation = performance.getEntriesByType('navigation')[0];
          if (navigation && navigation.type === 'navigate') {
            isRealPageUnload = true;
          }
          
          // 페이지 새로고침이나 내부 네비게이션이 아닌 경우 상태 정리
          if (isRealPageUnload && hasJoinedGame) {
            hasJoinedGame = false;
          }
        });

        // 페이지 숨김/표시 처리 (탭 전환, 앱 전환 등) - Phaser 게임 메모리 절약용
        document.addEventListener("visibilitychange", () => {
          if (document.hidden && isPageVisible) {
            // 페이지가 숨겨짐 - Phaser 게임 일시정지 (메모리 절약)
            isPageVisible = false;
            
            if (miniGame && miniGame.scene && miniGame.scene.scenes.length > 0) {
              try {
                miniGame.scene.scenes.forEach(scene => {
                  if (scene && scene.sys && !scene.sys.isDestroyed && scene.scene.isPaused) {
                    scene.scene.pause();
                  }
                });
              } catch (error) {
                // 에러 무시
              }
            }
          } else if (!document.hidden && !isPageVisible) {
            // 페이지가 다시 보임 - Phaser 게임 재개
            isPageVisible = true;
            
            if (miniGame && miniGame.scene && miniGame.scene.scenes.length > 0) {
              try {
                miniGame.scene.scenes.forEach(scene => {
                  if (scene && scene.sys && !scene.sys.isDestroyed && scene.scene.isPaused()) {
                    scene.scene.resume();
                  }
                });
              } catch (error) {
                // 에러 무시
              }
            }
          }
        });

        // 사용자 자동 게임 관련 이벤트들 제거됨 - 관리자만 게임 제어 가능

        let selectedChoice = null;
        let selectedChipAmount = 0;
        let bettingActive = false;
        let lastBetChoice = null; // 마지막 베팅 정보 저장
        let lastBetAmount = 0;
        let miniGame = null; // Phaser 게임 인스턴스 변수
        let baccaratSceneMini = null; // Phaser Scene 인스턴스 변수
        let isBettingInProgress = false; // 베팅 처리 중 플래그
        let currentBets = {}; // 현재 베팅 상황 추적
        


        // 채팅 관련 변수들
        let isChatOpen = false;
        let unreadChatCount = 0;
        let isHighlightMode = false;

        // DOM 요소 가져오기
        const chargeExchangeModal = document.getElementById(
          "chargeExchangeModal"
        );
        const historyModal = document.getElementById("historyModal");
        const myInfoModal = document.getElementById("myInfoModal");
        const winMessage = document.getElementById("winMessage");

        const showChargeExchangeButton =
          document.getElementById("showChargeExchange");
        const closeChargeExchangeButton = document.getElementById(
          "closeChargeExchange"
        );
        const showHistoryButton = document.getElementById("showHistory");
        const closeHistoryButton = document.getElementById("closeHistory");
        const showMyInfoButton = document.getElementById("showMyInfo");
        const closeMyInfoButton = document.getElementById("closeMyInfo");

        // 탭 관련 요소들
        const chargeTab = document.getElementById("chargeTab");
        const exchangeTab = document.getElementById("exchangeTab");
        const historyTab = document.getElementById("historyTab");
        const transferTab = document.getElementById("transferTab");
        const chargeContent = document.getElementById("chargeContent");
        const exchangeContent = document.getElementById("exchangeContent");
        const historyContent = document.getElementById("historyContent");
        const transferContent = document.getElementById("transferContent");

        const exchangeAmountInput = document.getElementById("exchangeAmount");
        const modalCoinBalance = document.getElementById("modalCoinBalance");
        const modalCoinBalance2 = document.getElementById("modalCoinBalance2");
        const rollingInfoDiv = document.getElementById("rollingInfo");
        const exchangePreview = document.getElementById("exchangePreview");
        const requestAmountSpan = document.getElementById("requestAmount");
        const feeAmountSpan = document.getElementById("feeAmount");
        const actualAmountSpan = document.getElementById("actualAmount");
        const maxAmountButton = document.getElementById("maxAmount");
        const submitExchangeButton = document.getElementById("submitExchange");

        // 환전 신청 완료 모달 관련 요소들
        const exchangeRequestModal = document.getElementById(
          "exchangeRequestModal"
        );
        const closeExchangeRequestModal = document.getElementById(
          "closeExchangeRequestModal"
        );
        const modalRequestAmount =
          document.getElementById("modalRequestAmount");
        const modalDeductedAmount = document.getElementById(
          "modalDeductedAmount"
        );
        const modalCurrentBalance = document.getElementById(
          "modalCurrentBalance"
        );

        // 채팅 관련 DOM 요소들
        const chatFloatingButton =
          document.getElementById("chatFloatingButton");
        const chatWindow = document.getElementById("chatWindow");
        const chatOverlay = document.getElementById("chatOverlay");
        const closeChatButton = document.getElementById("closeChatButton");
        const chatMessages = document.getElementById("chatMessages");
        const chatMessageInput = document.getElementById("chatMessageInput");
        const sendChatButton = document.getElementById("sendChatButton");
        const highlightChatButton = document.getElementById(
          "highlightChatButton"
        );
        const chatCharCount = document.getElementById("chatCharCount");
        const chatNotificationBadge = document.getElementById(
          "chatNotificationBadge"
        );
        const chatNotificationCount = document.getElementById(
          "chatNotificationCount"
        );
        const highlightModeIndicator = document.getElementById(
          "highlightModeIndicator"
        );
        const adminMessageBar = document.getElementById("adminMessageBar");
        const adminMessageBarContainer = document.getElementById(
          "adminMessageBarContainer"
        );
        const adminMessageBarIcon = document.getElementById(
          "adminMessageBarIcon"
        );
        const adminMessageBarSender = document.getElementById(
          "adminMessageBarSender"
        );
        const adminMessageBarTime = document.getElementById(
          "adminMessageBarTime"
        );
        const adminMessageBarContent = document.getElementById(
          "adminMessageBarContent"
        );
        const closeAdminMessageBar = document.getElementById(
          "closeAdminMessageBar"
        );

        // ===========================
        // 바카라 로드 계산 및 그리기 함수 (수정된 정확한 버전)
        // ===========================

        /**
         * 빅로드 매트릭스를 기반으로 화면에 그리기
         * @param {Array<Array<Object>>} matrix - 빅로드를 나타내는 2차원 배열
         * @param {number} maxCols - 렌더링할 열의 수
         */
        function renderBigRoad(matrix, maxCols) {
          const container = document.getElementById("recentResults");
          if (!container) return;
          container.innerHTML = "";

          const MAX_ROWS = 6;
          for (let c = 0; c < maxCols; c++) {
            let colHasContent = false;
            for (let r = 0; r < MAX_ROWS; r++) {
              if (matrix[r] && matrix[r][c]) {
                colHasContent = true;
                break;
              }
            }

            // 드래곤 테일 확인
            if (!colHasContent && c > 0) {
              for (let tailCol = c; tailCol < maxCols; tailCol++) {
                if (matrix[MAX_ROWS - 1] && matrix[MAX_ROWS - 1][tailCol]) {
                  colHasContent = true;
                  break;
                }
              }
            }

            if (!colHasContent) continue;

            const colEl = document.createElement("div");
            colEl.className = "result-column";

            for (let r = 0; r < MAX_ROWS; r++) {
              const result = matrix[r] ? matrix[r][c] : null;
              const cellEl = document.createElement("div");

              if (result) {
                cellEl.className = `result-cell ${
                  result.winner === "p" || result.winner === "player"
                    ? "player"
                    : "banker"
                }`;
                cellEl.style.position = "relative";

                // 페어 마커 추가
                if (result.pair === "p") {
                  const pairDot = document.createElement("div");
                  pairDot.style.cssText =
                    "position: absolute; width: 6px; height: 6px; background-color: #3b82f6; border-radius: 50%; bottom: 0px; left: 0px;";
                  cellEl.appendChild(pairDot);
                } else if (result.pair === "b") {
                  const pairDot = document.createElement("div");
                  pairDot.style.cssText =
                    "position: absolute; width: 6px; height: 6px; background-color: #ef4444; border-radius: 50%; top: 0px; right: 0px;";
                  cellEl.appendChild(pairDot);
                }

                // 타이 마커 추가
                if (result.tieCount > 0) {
                  const tieSlash = document.createElement("div");
                  tieSlash.style.cssText =
                    "position: absolute; width: 18px; height: 3px; background-color: #10b981; transform: rotate(45deg); top: 50%; left: 50%; margin-left: -9px; margin-top:-1.5px; transform-origin: center; border-radius: 1px;";
                  cellEl.appendChild(tieSlash);
                  if (result.tieCount > 1) {
                    const tieCountText = document.createElement("span");
                    tieCountText.textContent = result.tieCount;
                    tieCountText.style.cssText =
                      "position: absolute; right: 1px; bottom: 0px; font-size: 8px; color: white; line-height:1; text-shadow: 1px 1px 1px black;";
                    cellEl.appendChild(tieCountText);
                  }
                }
              } else {
                cellEl.className = "result-cell";
                cellEl.style.visibility = "hidden";
              }
              colEl.appendChild(cellEl);
            }
            container.appendChild(colEl);
          }
        }

        /**
         * 파생 로드 렌더링 (빅아이, 스몰, 코크로치)
         * @param {string} containerId - 컨테이너 요소의 ID
         * @param {Array<string>} results - 결과 배열 ('player'는 파랑, 'banker'는 빨강)
         * @param {number} maxRows - 이 로드의 최대 행 수
         */
        function renderDerivedRoad(containerId, results, maxRows) {
          const container = document.getElementById(containerId);
          if (!container) return;
          container.innerHTML = "";
          if (!results || results.length === 0) return;

          const MAX_COLS = 100;
          const matrix = Array(maxRows)
            .fill(0)
            .map(() => Array(MAX_COLS).fill(null));
          let col = 0;
          let row = 0;
          let lastResult = null;
          let totalCols = 0;

          results.forEach((result) => {
            if (lastResult && result !== lastResult) {
              col++;
              row = 0;
            }

            let r_coord = row;
            let c_coord = col;

            if (row >= maxRows) {
              // 드래곤 테일
              r_coord = maxRows - 1;
              c_coord = col + (row - (maxRows - 1));
            }

            if (r_coord < maxRows && c_coord < MAX_COLS) {
              if (!matrix[r_coord]) matrix[r_coord] = [];
              matrix[r_coord][c_coord] = result;
              totalCols = Math.max(totalCols, c_coord);
            }

            row++;
            lastResult = result;
          });

          // 매트릭스 렌더링
          for (let c = 0; c <= totalCols; c++) {
            let colHasContent = false;
            for (let r = 0; r < maxRows; r++) {
              if (matrix[r] && matrix[r][c]) {
                colHasContent = true;
                break;
              }
            }
            if (!colHasContent) continue;

            const colEl = document.createElement("div");
            colEl.className = "result-column";

            for (let r = 0; r < maxRows; r++) {
              const result = matrix[r] ? matrix[r][c] : null;
              const cellEl = document.createElement("div");
              cellEl.className = "derived-road-cell";

              if (result) {
                cellEl.classList.add(result);
              } else {
                cellEl.style.visibility = "hidden";
              }
              colEl.appendChild(cellEl);
            }
            container.appendChild(colEl);
          }
        }

        /**
         * 빅로드 히스토리를 기반으로 모든 파생 로드 계산
         * 표준 카지노 규칙을 따름
         * @param {Array<Object>} history - 전체 게임 히스토리
         * @returns {Object} 각 파생 로드의 배열을 포함하는 객체
         */
        function calculateAllDerivedRoads(history) {
          const roads = { bigEye: [], small: [], cockroach: [] };
          const nonTieHistory = history.filter((h) => h.winner !== "tie");
          if (nonTieHistory.length <= 1) return roads;

          // 빅로드에서 각 비타이 결과의 좌표 결정
          let coords = [];
          let col = 0,
            row = 0,
            lastWinner = null;

          nonTieHistory.forEach((res) => {
            if (lastWinner && res.winner !== lastWinner) {
              col++;
              row = 0;
            }
            coords.push({ r: row, c: col, winner: res.winner });
            lastWinner = res.winner;
            row++;
          });

          const getColDepth = (colIndex) =>
            coords.filter((p) => p.c === colIndex).length;

          // 두 번째 엔트리부터 파생 로드 결과 생성
          for (let i = 1; i < coords.length; i++) {
            const { r, c } = coords[i];

            // 모든 로드 로직을 위한 헬퍼
            const checkConsistency = (offset1, offset2) => {
              if (c < offset2) return null;
              const col1_depth = getColDepth(c - offset1);
              const col2_depth = getColDepth(c - offset2);
              return col1_depth === col2_depth ? "banker" : "player";
            };

            const checkDropDown = (offset) => {
              if (c < offset) return null;
              // 비교 열에서 해당 셀 찾기
              const refCell = coords.find(
                (p) => p.c === c - offset && p.r === r
              );
              // 바로 위 셀 찾기
              const refCellAbove = coords.find(
                (p) => p.c === c - offset && p.r === r - 1
              );

              if (refCell) {
                return refCellAbove ? "banker" : "player";
              } else {
                return refCellAbove ? "player" : "banker";
              }
            };

            // 빅아이로드 로직 (col-1과 col-2 비교)
            if (r === 0) {
              const result = checkConsistency(1, 2);
              if (result) roads.bigEye.push(result);
            } else {
              const result = checkDropDown(1);
              if (result) roads.bigEye.push(result);
            }

            // 스몰로드 로직 (col-1과 col-3 비교)
            if (r === 0) {
              const result = checkConsistency(1, 3);
              if (result) roads.small.push(result);
            } else {
              const result = checkDropDown(2);
              if (result) roads.small.push(result);
            }

            // 코크로치로드 로직 (col-1과 col-4 비교)
            if (r === 0) {
              const result = checkConsistency(1, 4);
              if (result) roads.cockroach.push(result);
            } else {
              const result = checkDropDown(3);
              if (result) roads.cockroach.push(result);
            }
          }

          return roads;
        }

        /**
         * 모든 스코어보드를 업데이트하고 렌더링하는 메인 함수
         * @param {Array<Object>} history - 서버에서 받은 전체 게임 히스토리
         */
        function updateScoreboard(history) {
          if (!history) return;

          // 1. 히스토리에서 빅로드 매트릭스 구축
          const MAX_ROWS = 6;
          const MAX_COLS = 150;
          const bigRoadMatrix = Array(MAX_ROWS)
            .fill(0)
            .map(() => Array(MAX_COLS).fill(null));
          let col = 0,
            row = 0,
            lastWinner = null;
          let totalCols = 0;

          history.forEach((result) => {
            const { winner, pair } = result;
            if (winner === "tie") {
              // 마지막에 놓인 마커에 타이 카운트 추가
              let lastR, lastC;
              if (row > 0) {
                lastR = row - 1;
                lastC = col;
              } else if (col > 0) {
                lastC = col - 1;
                lastR = -1;
                for (let i = 0; i < MAX_ROWS; i++) {
                  if (bigRoadMatrix[i] && bigRoadMatrix[i][lastC]) lastR = i;
                  else break;
                }
                // 드래곤 테일 확인
                if (lastR === MAX_ROWS - 1) {
                  let tail_c = lastC + 1;
                  while (bigRoadMatrix[lastR] && bigRoadMatrix[lastR][tail_c]) {
                    lastC = tail_c;
                    tail_c++;
                  }
                }
              }

              if (lastR !== undefined && lastR > -1 && lastC !== undefined) {
                if (bigRoadMatrix[lastR] && bigRoadMatrix[lastR][lastC]) {
                  bigRoadMatrix[lastR][lastC].tieCount =
                    (bigRoadMatrix[lastR][lastC].tieCount || 0) + 1;
                }
              }
            } else {
              // 플레이어 또는 뱅커 승리
              if (lastWinner && winner !== lastWinner) {
                col++;
                row = 0;
              }
              const currentResult = {
                winner: winner.toLowerCase(),
                pair: pair ? pair.toLowerCase() : null,
                tieCount: 0,
              };
              lastWinner = winner;

              let r_coord = row,
                c_coord = col;
              if (row >= MAX_ROWS) {
                // 드래곤 테일
                r_coord = MAX_ROWS - 1;
                c_coord = col + (row - (MAX_ROWS - 1));
              }

              if (r_coord < MAX_ROWS && c_coord < MAX_COLS) {
                if (!bigRoadMatrix[r_coord]) bigRoadMatrix[r_coord] = [];
                bigRoadMatrix[r_coord][c_coord] = currentResult;
              }
              totalCols = Math.max(totalCols, c_coord);
              row++;
            }
          });

          // 2. 히스토리 기반 방법으로 파생 로드 계산
          const derivedRoads = calculateAllDerivedRoads(history);

          // 3. 모든 것 렌더링
          renderBigRoad(bigRoadMatrix, totalCols + 15);
          renderDerivedRoad("bigEyeRoad", derivedRoads.bigEye, 6);
          renderDerivedRoad("smallRoad", derivedRoads.small, 3);
          renderDerivedRoad("cockroachRoad", derivedRoads.cockroach, 3);
        }

        // 탭 전환 기능
        function switchTab(activeTab) {
          // 모든 탭 버튼 초기화
          [chargeTab, exchangeTab, historyTab, transferTab].forEach((tab) => {
            if (tab) {
              tab.className =
                "flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors text-gray-400 hover:text-yellow-500";
            }
          });

          // 모든 탭 컨텐츠 숨기기
          [
            chargeContent,
            exchangeContent,
            historyContent,
            transferContent,
          ].forEach((content) => {
            if (content) content.classList.add("hidden");
          });

          // 활성 탭 설정
          if (activeTab === "charge") {
            if (chargeTab)
              chargeTab.className =
                "flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors golden-btn";
            if (chargeContent) chargeContent.classList.remove("hidden");
          } else if (activeTab === "exchange") {
            if (exchangeTab)
              exchangeTab.className =
                "flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors golden-btn";
            if (exchangeContent) exchangeContent.classList.remove("hidden");
          } else if (activeTab === "history") {
            if (historyTab)
              historyTab.className =
                "flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors golden-btn";
            if (historyContent) historyContent.classList.remove("hidden");
            // 환전 내역 로드
            fetchExchangeHistory();
          } else if (activeTab === "transfer") {
            if (transferTab)
              transferTab.className =
                "flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors golden-btn";
            if (transferContent) transferContent.classList.remove("hidden");
            // 사용자 목록 로드
            fetchUsersList();
            // 현재 활성화된 뽀찌 내부 탭에 따라 데이터 로드
            if (
              !document
                .getElementById("sendMoneySection")
                .classList.contains("hidden")
            ) {
              // 송금하기 탭이 활성화되어 있으면 아무것도 안함 (이미 사용자 목록 로드됨)
            } else if (
              !document
                .getElementById("requestMoneySection")
                .classList.contains("hidden")
            ) {
              // 요청하기 탭이 활성화되어 있으면 아무것도 안함 (이미 사용자 목록 로드됨)
            } else if (
              !document
                .getElementById("transferHistorySection")
                .classList.contains("hidden")
            ) {
              // 내역보기 탭이 활성화되어 있으면 받은 요청과 송금 내역 로드
              fetchReceivedRequests();
              fetchTransferHistory();
            } else {
              // 기본적으로 송금하기 탭 활성화
              switchTransferMode("send");
            }
          }
        }

        // 탭 클릭 이벤트
        if (chargeTab)
          chargeTab.addEventListener("click", () => switchTab("charge"));
        if (exchangeTab)
          exchangeTab.addEventListener("click", () => switchTab("exchange"));
        if (historyTab)
          historyTab.addEventListener("click", () => switchTab("history"));
        if (transferTab)
          transferTab.addEventListener("click", () => switchTab("transfer"));

        // ===========================
        // 채팅 관련 함수들
        // ===========================

        // 채팅창 열기/닫기
        function toggleChat() {
          if (isChatOpen) {
            closeChatWindow();
          } else {
            openChatWindow();
          }
        }

        function openChatWindow() {
          if (chatWindow && chatOverlay && chatFloatingButton) {
            chatOverlay.classList.remove("hidden");
            chatWindow.classList.remove("hidden");
            chatFloatingButton.style.opacity = "0.5";
            isChatOpen = true;

            // 읽지 않은 메시지 카운트 초기화
            unreadChatCount = 0;
            updateChatNotificationBadge();

            // 스크롤을 맨 아래로
            if (chatMessages) {
              setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
              }, 100);
            }

            // 채팅 기록 로드
            loadChatHistory();
          }
        }

        function closeChatWindow() {
          if (chatWindow && chatOverlay && chatFloatingButton) {
            chatOverlay.classList.add("hidden");
            chatWindow.classList.add("hidden");
            chatFloatingButton.style.opacity = "1";
            isChatOpen = false;
          }
        }

        // 채팅 기록 로드
        async function loadChatHistory() {
          try {
            const res = await fetch(
              "https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/chat/messages",
              {
                headers: { Authorization: `Bearer ${token}` },
              }
            );

            if (res.ok) {
              const messages = await res.json();
              displayChatMessages(messages);
            }
          } catch (err) {
            console.error("채팅 기록 로드 오류:", err);
          }
        }

        // 채팅 메시지들 표시
        function displayChatMessages(messages) {
          if (!chatMessages) return;

          chatMessages.innerHTML = "";
          messages.forEach((message) => {
            appendChatMessage(message);
          });

          // 스크롤을 맨 아래로
          setTimeout(() => {
            chatMessages.scrollTop = chatMessages.scrollHeight;
          }, 100);
        }

        // 채팅 메시지 추가
        function appendChatMessage(message) {
          if (!chatMessages) return;

          const messageEl = document.createElement("div");
          messageEl.className = `chat-message ${
            message.isAdmin ? "admin-message" : "user-message"
          } ${message.isHighlighted ? "highlight-message" : ""}`;

          const timeStr = new Date(message.createdAt).toLocaleTimeString(
            "ko-KR",
            {
              hour: "2-digit",
              minute: "2-digit",
            }
          );

          const adminBadge = message.isAdmin
            ? '<span class="inline-block px-2 py-1 bg-yellow-500 text-black text-xs font-bold rounded-full mr-2">관리자</span>'
            : "";
          const highlightBadge = "";

          let bgClass = "bg-black bg-opacity-30 rounded-lg p-3";
          if (message.isAdmin) {
            bgClass =
              "bg-yellow-500 bg-opacity-10 border border-yellow-500 rounded-lg p-3";
          } else if (message.isHighlighted) {
            bgClass =
              "bg-black bg-opacity-30 border border-orange-400 rounded-lg p-3";
          }

          const messageText = message.isHighlighted
            ? ` ${message.message}`
            : message.message;

          messageEl.innerHTML = `
            <div class="flex flex-col ${bgClass}">
              <div class="flex items-center justify-between mb-1">
                <div class="flex items-center">
                  ${adminBadge}
                  ${highlightBadge}
                  <span class="font-bold ${
                    message.isAdmin
                      ? "text-yellow-500"
                      : message.isHighlighted
                      ? "text-orange-300"
                      : "text-white"
                  } text-sm">${message.username}</span>
                </div>
                <span class="text-gray-400 text-xs">${timeStr}</span>
              </div>
              <p class="text-white text-sm break-words">${escapeHtml(
                messageText
              )}</p>
            </div>
          `;

          chatMessages.appendChild(messageEl);
        }

        // HTML 이스케이프 함수
        function escapeHtml(text) {
          const div = document.createElement("div");
          div.textContent = text;
          return div.innerHTML;
        }

        // 채팅 메시지 전송
        async function sendChatMessage() {
          const message = chatMessageInput?.value.trim();
          if (!message || message.length > 500) return;

          try {
            if (isHighlightMode) {
              // 강조 모드일 때 강조 메시지 전송
              socket.emit("send_highlight_message", { message });
              // 강조 모드 자동 해제
              toggleHighlightMode();
            } else {
              // 일반 메시지 전송
              socket.emit("send_chat_message", { message });
            }

            // 입력창 초기화
            if (chatMessageInput) {
              chatMessageInput.value = "";
              updateCharCount();
            }
          } catch (err) {
            console.error("채팅 전송 오류:", err);
            showNotification("채팅 전송에 실패했습니다.");
          }
        }

        // 강조 모드 토글
        function toggleHighlightMode() {
          isHighlightMode = !isHighlightMode;

          if (isHighlightMode) {
            // 강조 모드 활성화
            highlightChatButton.className =
              "px-3 py-2 bg-gradient-to-r from-[#ff6b35] to-[#ff8c42] text-white rounded-lg hover:from-[#ff8c42] hover:to-[#ffa726] transition-all duration-300 font-bold text-sm";
            highlightModeIndicator.classList.remove("hidden");
            chatMessageInput.placeholder = "강조 메시지를 입력하세요...";
            chatMessageInput.classList.add("border-orange-400");
            chatMessageInput.classList.remove("border-[#b8860b]");
          } else {
            // 강조 모드 비활성화
            highlightChatButton.className =
              "px-3 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-500 transition-all duration-300 font-bold text-sm";
            highlightModeIndicator.classList.add("hidden");
            chatMessageInput.placeholder = "메시지를 입력하세요...";
            chatMessageInput.classList.remove("border-orange-400");
            chatMessageInput.classList.add("border-[#b8860b]");
          }
        }

        // 문자 수 업데이트
        function updateCharCount() {
          if (chatMessageInput && chatCharCount) {
            const count = chatMessageInput.value.length;
            chatCharCount.textContent = count;

            if (count > 450) {
              chatCharCount.style.color = "#ef4444"; // 빨간색
            } else if (count > 350) {
              chatCharCount.style.color = "#f59e0b"; // 주황색
            } else {
              chatCharCount.style.color = "#6b7280"; // 회색
            }
          }
        }

        // 채팅 알림 뱃지 업데이트
        function updateChatNotificationBadge() {
          if (chatNotificationBadge && chatNotificationCount) {
            if (unreadChatCount > 0 && !isChatOpen) {
              chatNotificationBadge.classList.remove("hidden");
              chatNotificationCount.textContent =
                unreadChatCount > 99 ? "99+" : unreadChatCount;
            } else {
              chatNotificationBadge.classList.add("hidden");
            }
          }
        }

        // 소리 알림 (간단한 알림음)
        function playNotificationSound() {
          try {
            // 간단한 알림음 효과
            const audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.setValueAtTime(
              600,
              audioContext.currentTime + 0.1
            );

            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.2
            );

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
          } catch (err) {
            // 오디오 재생 실패 시 무시
          }
        }

        // 메시지 알림 바 표시 (관리자 & 강조 메시지 공용)
        function showMessageBar(message, isHighlight = false) {
          if (
            adminMessageBar &&
            adminMessageBarContent &&
            adminMessageBarTime &&
            adminMessageBarSender &&
            adminMessageBarContainer &&
            adminMessageBarIcon
          ) {
            // 메시지 내용 설정
            adminMessageBarContent.textContent = message.message;
            adminMessageBarTime.textContent = new Date(
              message.createdAt
            ).toLocaleTimeString("ko-KR", {
              hour: "2-digit",
              minute: "2-digit",
            });

            if (isHighlight) {
              // 강조 메시지 스타일 (관리자 메시지와 동일한 투명 배경)
              adminMessageBarSender.textContent = message.username;
              adminMessageBarSender.className =
                "text-orange-400 font-bold text-sm";
              adminMessageBarContainer.className =
                "bg-black bg-opacity-30 mx-4 rounded-lg backdrop-blur-md border border-orange-400";
              adminMessageBarIcon.className =
                "w-5 h-5 text-orange-400 animate-pulse";
              adminMessageBarIcon.innerHTML =
                '<path fill-rule="evenodd" d="M12.395 2.553a1 1 0 00-1.45-.385c-.345.23-.614.558-.822.88-.214.33-.403.713-.57 1.116-.334.804-.614 1.768-.84 2.734a31.365 31.365 0 00-.613 3.58 2.64 2.64 0 01-.945-1.067c-.328-.68-.398-1.534-.398-2.654A1 1 0 005.05 6.05 6.981 6.981 0 003 11a7 7 0 1011.95-4.95c-.592-.591-.98-.985-1.348-1.467-.363-.476-.724-1.063-1.207-2.03zM12.12 15.12A3 3 0 017 13s.879.5 2.5.5c0-1 .5-4 1.25-4.5.5 1 .786 1.293 1.371 1.879A2.99 2.99 0 0112.12 15.12z" clip-rule="evenodd"></path>';

              // 강조 메시지는 2초 후 숨기기
              setTimeout(() => {
                hideMessageBar();
              }, 2000);
            } else {
              // 관리자 메시지 스타일
              adminMessageBarSender.textContent = "관리자";
              adminMessageBarSender.className =
                "text-yellow-400 font-bold text-sm";
              adminMessageBarContainer.className =
                "bg-black bg-opacity-30 mx-4 rounded-lg backdrop-blur-md border border-white border-opacity-20";
              adminMessageBarIcon.className = "w-5 h-5 text-yellow-400";
              adminMessageBarIcon.innerHTML =
                '<path fill-rule="evenodd" d="M18 3a1 1 0 00-1.447-.894L8.763 6H5a3 3 0 000 6h.28l1.771 5.316A1 1 0 008 18h1a1 1 0 001-1v-4.382l6.553 3.276A1 1 0 0018 15V3z" clip-rule="evenodd"></path>';

              // 관리자 메시지는 3초 후 숨기기
              setTimeout(() => {
                hideMessageBar();
              }, 3000);
            }

            // hidden 클래스 제거하고 슬라이드 다운 애니메이션으로 표시
            adminMessageBar.classList.remove("hidden");
            adminMessageBar.classList.remove("-translate-y-full");
            adminMessageBar.classList.add("translate-y-0");
          }
        }

        // 메시지 알림 바 숨기기
        function hideMessageBar() {
          if (adminMessageBar) {
            adminMessageBar.classList.remove("translate-y-0");
            adminMessageBar.classList.add("-translate-y-full");

            // 완전히 숨기기 위해 hidden 클래스도 추가
            setTimeout(() => {
              adminMessageBar.classList.add("hidden");

              // 스타일을 기본 관리자 스타일로 초기화
              if (
                adminMessageBarContainer &&
                adminMessageBarSender &&
                adminMessageBarIcon &&
                adminMessageBarContent
              ) {
                adminMessageBarContainer.className =
                  "bg-black bg-opacity-30 mx-4 rounded-lg backdrop-blur-md border border-white border-opacity-20";
                adminMessageBarSender.className =
                  "text-yellow-400 font-bold text-sm";
                adminMessageBarSender.textContent = "관리자";
                adminMessageBarIcon.className = "w-5 h-5 text-yellow-400";
                adminMessageBarIcon.innerHTML =
                  '<path fill-rule="evenodd" d="M18 3a1 1 0 00-1.447-.894L8.763 6H5a3 3 0 000 6h.28l1.771 5.316A1 1 0 008 18h1a1 1 0 001-1v-4.382l6.553 3.276A1 1 0 0018 15V3z" clip-rule="evenodd"></path>';
                adminMessageBarContent.textContent = ""; // 내용도 초기화
                adminMessageBarTime.textContent = ""; // 시간도 초기화
              }
            }, 500); // 애니메이션 완료 후 초기화
          }
        }

        // 채팅 이벤트 리스너들
        if (chatFloatingButton) {
          chatFloatingButton.addEventListener("click", toggleChat);
        }

        if (closeChatButton) {
          closeChatButton.addEventListener("click", closeChatWindow);
        }

        if (chatOverlay) {
          chatOverlay.addEventListener("click", closeChatWindow);
        }

        if (sendChatButton) {
          sendChatButton.addEventListener("click", sendChatMessage);
        }

        if (highlightChatButton) {
          highlightChatButton.addEventListener("click", toggleHighlightMode);
        }

        if (chatMessageInput) {
          chatMessageInput.addEventListener("input", updateCharCount);
          chatMessageInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              sendChatMessage();
            }
          });
        }

        if (closeAdminMessageBar) {
          closeAdminMessageBar.addEventListener("click", () => {
            hideMessageBar();
          });
        }

        // 초기 문자 수 설정
        updateCharCount();

        // 페이지 로드 시 관리자 메시지 바 숨기기 (초기 상태)
        hideMessageBar();

        // 뽀찌 관련 변수 및 함수들
        let selectedUserId = null;
        let transferMode = "send"; // 'send' or 'request'

        // 뽀찌 내부 탭 전환
        function switchTransferMode(mode) {
          const sendMoneyBtn = document.getElementById("sendMoneyBtn");
          const requestMoneyBtn = document.getElementById("requestMoneyBtn");
          const transferHistoryBtn =
            document.getElementById("transferHistoryBtn");
          const sendMoneySection = document.getElementById("sendMoneySection");
          const requestMoneySection = document.getElementById(
            "requestMoneySection"
          );
          const transferHistorySection = document.getElementById(
            "transferHistorySection"
          );

          // 모든 버튼 초기화
          [sendMoneyBtn, requestMoneyBtn, transferHistoryBtn].forEach((btn) => {
            if (btn)
              btn.className =
                "flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors text-gray-400 hover:text-yellow-500";
          });

          // 모든 섹션 숨기기
          [
            sendMoneySection,
            requestMoneySection,
            transferHistorySection,
          ].forEach((section) => {
            if (section) section.classList.add("hidden");
          });

          // 활성화
          if (mode === "send") {
            if (sendMoneyBtn)
              sendMoneyBtn.className =
                "flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors golden-btn";
            if (sendMoneySection) sendMoneySection.classList.remove("hidden");
            transferMode = "send";
          } else if (mode === "request") {
            if (requestMoneyBtn)
              requestMoneyBtn.className =
                "flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors golden-btn";
            if (requestMoneySection)
              requestMoneySection.classList.remove("hidden");
            transferMode = "request";
          } else if (mode === "history") {
            if (transferHistoryBtn)
              transferHistoryBtn.className =
                "flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors golden-btn";
            if (transferHistorySection)
              transferHistorySection.classList.remove("hidden");
            fetchReceivedRequests();
          }
        }

        // 뽀찌 내부 탭 이벤트 리스너
        document
          .getElementById("sendMoneyBtn")
          ?.addEventListener("click", () => switchTransferMode("send"));
        document
          .getElementById("requestMoneyBtn")
          ?.addEventListener("click", () => switchTransferMode("request"));
        document
          .getElementById("transferHistoryBtn")
          ?.addEventListener("click", () => switchTransferMode("history"));

        // 사용자 목록 가져오기
        async function fetchUsersList() {
          try {
            const res = await fetch(
              "https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/users/list",
              {
                headers: { Authorization: `Bearer ${token}` },
              }
            );
            if (res.ok) {
              const users = await res.json();
              displayUsersList(users, "send");
              displayUsersList(users, "request");

              // 잔액 업데이트
              const balanceEl = document.getElementById("transferBalance");
              const userRes = await fetch(
                "https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/auth/user-info",
                {
                  headers: { Authorization: `Bearer ${token}` },
                }
              );
              if (userRes.ok) {
                const userData = await userRes.json();
                if (balanceEl)
                  balanceEl.textContent = `${userData.balance.toLocaleString()}원`;
              }
            } else {
              showNotification("사용자 목록을 가져오는 데 실패했습니다.");
            }
          } catch (err) {
            // 사용자 목록 조회 에러
            showNotification("서버 연결 오류가 발생했습니다.");
          }
        }

        // 사용자 목록 표시
        function displayUsersList(users, mode) {
          const listEl =
            mode === "send"
              ? document.getElementById("usersList")
              : document.getElementById("requestUsersList");
          if (!listEl) return;

          listEl.innerHTML = "";
          users.forEach((user) => {
            const userEl = document.createElement("div");
            userEl.className =
              "flex justify-between items-center p-2 hover:bg-black hover:bg-opacity-30 rounded cursor-pointer transition-colors";
            userEl.innerHTML = `
              <span class="text-white">${user.username}</span>
              <button class="text-yellow-500 hover:text-yellow-400 text-sm" data-user-id="${
                user._id
              }" data-username="${user.username}">
                ${mode === "send" ? "송금" : "요청"}
              </button>
            `;
            userEl.querySelector("button").addEventListener("click", (e) => {
              const userId = e.target.getAttribute("data-user-id");
              const username = e.target.getAttribute("data-username");
              selectUser(userId, username, mode);
            });
            listEl.appendChild(userEl);
          });
        }

        // 사용자 선택
        function selectUser(userId, username, mode) {
          selectedUserId = userId;
          if (mode === "send") {
            document.getElementById("selectedUserName").textContent = username;
            document.getElementById("sendMoneyForm").classList.remove("hidden");
          } else {
            document.getElementById("requestSelectedUserName").textContent =
              username;
            document
              .getElementById("requestMoneyForm")
              .classList.remove("hidden");
          }
        }

        // 사용자 검색
        document
          .getElementById("userSearchInput")
          ?.addEventListener("input", (e) => {
            const searchTerm = e.target.value.toLowerCase();
            filterUsers(searchTerm, "send");
          });

        document
          .getElementById("requestUserSearchInput")
          ?.addEventListener("input", (e) => {
            const searchTerm = e.target.value.toLowerCase();
            filterUsers(searchTerm, "request");
          });

        function filterUsers(searchTerm, mode) {
          const listEl =
            mode === "send"
              ? document.getElementById("usersList")
              : document.getElementById("requestUsersList");
          if (!listEl) return;

          const userElements = listEl.querySelectorAll("div");
          userElements.forEach((el) => {
            const username = el.querySelector("span").textContent.toLowerCase();
            if (username.includes(searchTerm)) {
              el.style.display = "flex";
            } else {
              el.style.display = "none";
            }
          });
        }

        // 송금 금액 입력 및 미리보기
        document
          .getElementById("sendAmount")
          ?.addEventListener("input", (e) => {
            const amount = parseInt(e.target.value);
            const previewEl = document.getElementById("sendPreview");
            const confirmBtn = document.getElementById("confirmSendButton");

            if (isNaN(amount) || amount < 1000) {
              previewEl.classList.add("hidden");
              confirmBtn.disabled = true;
              return;
            }

            const fee = Math.floor(amount * 0.05); // 5% 수수료
            const total = amount + fee;

            document.getElementById(
              "sendAmountPreview"
            ).textContent = `${amount.toLocaleString()}원`;
            document.getElementById(
              "sendFeePreview"
            ).textContent = `${fee.toLocaleString()}원`;
            document.getElementById(
              "sendTotalPreview"
            ).textContent = `${total.toLocaleString()}원`;
            previewEl.classList.remove("hidden");

            // 잔액 확인
            const balanceText = document
              .getElementById("transferBalance")
              .textContent.replace(/[^0-9]/g, "");
            const balance = parseInt(balanceText) || 0;

            confirmBtn.disabled = total > balance;
          });

        // 송금 요청
        document
          .getElementById("confirmSendButton")
          ?.addEventListener("click", async () => {
            const amount = parseInt(
              document.getElementById("sendAmount").value
            );
            if (!selectedUserId || !amount || amount < 1000) {
              showNotification("올바른 송금 정보를 입력해주세요.");
              return;
            }

            const confirmBtn = document.getElementById("confirmSendButton");
            confirmBtn.disabled = true;
            confirmBtn.textContent = "처리중...";

            try {
              const response = await fetch(
                "https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/transfer/send",
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${token}`,
                  },
                  body: JSON.stringify({
                    toUserId: selectedUserId,
                    amount: amount,
                  }),
                }
              );

              const data = await response.json();
              if (response.ok) {
                // 송금 성공 시 폼 초기화
                document.getElementById("sendAmount").value = "";
                document
                  .getElementById("sendMoneyForm")
                  .classList.add("hidden");
                document.getElementById("sendPreview").classList.add("hidden");
                selectedUserId = null;

                // 잔액 업데이트
                fetchUserInfo();

                // 송금 내역이 보이고 있다면 새로고침
                if (
                  !document
                    .getElementById("transferHistorySection")
                    .classList.contains("hidden")
                ) {
                  fetchTransferHistory();
                }
              } else {
                showNotification(data.message || "송금에 실패했습니다.");
              }
            } catch (error) {
              // 송금 에러
              showNotification("서버 연결 오류가 발생했습니다.");
            } finally {
              confirmBtn.disabled = false;
              confirmBtn.textContent = "송금하기";
            }
          });

        // 요청 금액 입력 검증
        document
          .getElementById("requestAmount")
          ?.addEventListener("input", (e) => {
            const amount = parseInt(e.target.value);
            const confirmBtn = document.getElementById("confirmRequestButton");
            confirmBtn.disabled = isNaN(amount) || amount < 1000;
          });

        // 머니 요청
        document
          .getElementById("confirmRequestButton")
          ?.addEventListener("click", async () => {
            const amount = parseInt(
              document.getElementById("requestAmount").value
            );
            const message = document.getElementById("requestMessage").value;

            if (!selectedUserId || !amount || amount < 1000) {
              showNotification("올바른 요청 정보를 입력해주세요.");
              return;
            }

            const confirmBtn = document.getElementById("confirmRequestButton");
            confirmBtn.disabled = true;
            confirmBtn.textContent = "처리중...";

            try {
              const response = await fetch(
                "https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/transfer/request",
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${token}`,
                  },
                  body: JSON.stringify({
                    fromUserId: selectedUserId,
                    amount: amount,
                    message: message,
                  }),
                }
              );

              const data = await response.json();
              if (response.ok) {
                // 요청 성공 시 폼 초기화
                document.getElementById("requestAmount").value = "";
                document.getElementById("requestMessage").value = "";
                document
                  .getElementById("requestMoneyForm")
                  .classList.add("hidden");
                selectedUserId = null;
              } else {
                showNotification(data.message || "요청 전송에 실패했습니다.");
              }
            } catch (error) {
              // 요청 전송 에러
              showNotification("서버 연결 오류가 발생했습니다.");
            } finally {
              confirmBtn.disabled = false;
              confirmBtn.textContent = "요청하기";
            }
          });

        // 받은 요청 목록 가져오기
        async function fetchReceivedRequests() {
          try {
            const res = await fetch(
              "https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/transfer/requests/received",
              {
                headers: { Authorization: `Bearer ${token}` },
              }
            );
            if (res.ok) {
              const requests = await res.json();
              displayReceivedRequests(requests);
            }
          } catch (err) {
            // 받은 요청 조회 에러
          }
        }

        // 받은 요청 표시
        function displayReceivedRequests(requests) {
          const listEl = document.getElementById("receivedRequestsList");
          if (!listEl) return;

          listEl.innerHTML = "";
          if (requests.length === 0) {
            listEl.innerHTML =
              '<div class="text-center text-gray-400 py-2">받은 요청이 없습니다.</div>';
            return;
          }

          requests.forEach((request) => {
            const reqEl = document.createElement("div");
            reqEl.className =
              "bg-black bg-opacity-50 p-3 rounded-lg border border-[#b8860b]";
            reqEl.innerHTML = `
              <div class="flex justify-between items-start mb-2">
                <div>
                  <div class="text-yellow-500 font-bold">${
                    request.fromUser.username
                  }</div>
                  <div class="text-sm text-gray-400">${new Date(
                    request.createdAt
                  ).toLocaleString()}</div>
                </div>
                <div class="text-right">
                  <div class="text-lg font-bold text-white">${request.amount.toLocaleString()}원</div>
                  <div class="text-xs text-gray-400">수수료 ${Math.floor(
                    request.amount * 0.05
                  ).toLocaleString()}원</div>
                </div>
              </div>
              ${
                request.message
                  ? `<div class="text-sm text-gray-300 mb-2">${request.message}</div>`
                  : ""
              }
              <div class="flex gap-2">
                <button class="flex-1 golden-btn py-2 rounded text-sm" onclick="acceptRequest('${
                  request._id
                }', ${request.amount})">
                  수락
                </button>
                <button class="flex-1 bg-gray-600 hover:bg-gray-700 py-2 rounded text-sm text-white" onclick="rejectRequest('${
                  request._id
                }')">
                  거절
                </button>
              </div>
            `;
            listEl.appendChild(reqEl);
          });
        }

        // 요청 수락/거절 함수를 전역으로 등록
        window.acceptRequest = async (requestId, amount) => {
          const total = amount + Math.floor(amount * 0.05);
          const balanceText = document
            .getElementById("transferBalance")
            ?.textContent.replace(/[^0-9]/g, "");
          const balance = parseInt(balanceText) || 0;

          if (total > balance) {
            showNotification("잔액이 부족합니다.");
            return;
          }

          try {
            const response = await fetch(
              `https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/transfer/request/${requestId}/accept`,
              {
                method: "POST",
                headers: { Authorization: `Bearer ${token}` },
              }
            );

            const data = await response.json();
            if (response.ok) {
              showNotification("요청을 수락했습니다.");
              fetchReceivedRequests();
              fetchUserInfo();
            } else {
              showNotification(data.message || "요청 수락에 실패했습니다.");
            }
          } catch (error) {
            // 요청 수락 에러
            showNotification("서버 연결 오류가 발생했습니다.");
          }
        };

        window.rejectRequest = async (requestId) => {
          try {
            const response = await fetch(
              `https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/transfer/request/${requestId}/reject`,
              {
                method: "POST",
                headers: { Authorization: `Bearer ${token}` },
              }
            );

            const data = await response.json();
            if (response.ok) {
              showNotification("요청을 거절했습니다.");
              fetchReceivedRequests();
            } else {
              showNotification(data.message || "요청 거절에 실패했습니다.");
            }
          } catch (error) {
            // 요청 거절 에러
            showNotification("서버 연결 오류가 발생했습니다.");
          }
        };

        // 송금 내역 가져오기
        async function fetchTransferHistory() {
          try {
            const res = await fetch(
              "https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/transfer/history",
              {
                headers: { Authorization: `Bearer ${token}` },
              }
            );
            if (res.ok) {
              const history = await res.json();
              displayTransferHistory(history);
            }
          } catch (err) {
            // 송금 내역 조회 에러
          }
        }

        // 송금 내역 표시
        function displayTransferHistory(history) {
          const listEl = document.getElementById("transferHistoryList");
          if (!listEl) return;

          listEl.innerHTML = "";
          if (history.length === 0) {
            listEl.innerHTML =
              '<div class="text-center text-gray-400 py-2">송금 내역이 없습니다.</div>';
            return;
          }

          history.forEach((transfer) => {
            const transEl = document.createElement("div");
            transEl.className =
              "bg-black bg-opacity-50 p-3 rounded-lg border border-[#b8860b]";
            const isSent = transfer.type === "sent";
            transEl.innerHTML = `
              <div class="flex justify-between items-center">
                <div>
                  <div class="text-sm ${
                    isSent ? "text-red-400" : "text-green-400"
                  }">
                    ${isSent ? "송금" : "수신"}
                  </div>
                  <div class="text-white font-bold">
                    ${
                      isSent
                        ? transfer.toUser.username
                        : transfer.fromUser.username
                    }
                  </div>
                  <div class="text-xs text-gray-400">${new Date(
                    transfer.createdAt
                  ).toLocaleString()}</div>
                </div>
                <div class="text-right">
                  <div class="text-lg font-bold ${
                    isSent ? "text-red-400" : "text-green-400"
                  }">
                    ${isSent ? "-" : "+"}${transfer.amount.toLocaleString()}원
                  </div>
                  ${
                    transfer.fee > 0
                      ? `<div class="text-xs text-gray-400">수수료 ${transfer.fee.toLocaleString()}원</div>`
                      : ""
                  }
                </div>
              </div>
            `;
            listEl.appendChild(transEl);
          });
        }

        // 충전 신청 관련 이벤트 리스너 추가
        const depositAmountInput = document.getElementById("depositAmount");
        const submitDepositButton = document.getElementById("submitDeposit");

        // 충전 금액 버튼 클릭 이벤트
        document.querySelectorAll(".deposit-amount-btn").forEach((button) => {
          button.addEventListener("click", function () {
            const amount = parseInt(this.getAttribute("data-deposit-amount"));
            if (depositAmountInput) {
              depositAmountInput.value = amount;
            }
          });
        });

        // 충전 신청 버튼 클릭 이벤트
        if (submitDepositButton) {
          submitDepositButton.addEventListener("click", async () => {
            const amount = parseInt(depositAmountInput?.value || "0");

            if (!amount || isNaN(amount) || amount < 10000) {
              showNotification("충전 금액은 최소 10,000원 이상이어야 합니다.");
              return;
            }

            submitDepositButton.disabled = true;
            submitDepositButton.textContent = "처리중...";

            try {
              const response = await fetch(
                "https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/deposit/request",
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${token}`,
                  },
                  body: JSON.stringify({ amount }),
                }
              );

              const data = await response.json();

              if (response.ok) {
                showNotification(
                  "충전 신청이 완료되었습니다. 관리자 승인을 기다려주세요."
                );
                if (depositAmountInput) depositAmountInput.value = "";
                chargeExchangeModal.classList.add("hidden");
                // 충전 내역 새로고침 (있다면)
                // await fetchDepositHistory();
              } else {
                showNotification(data.message || "충전 신청에 실패했습니다.");
              }
            } catch (error) {
              // 충전 신청 에러
              showNotification("서버 연결 오류가 발생했습니다.");
            } finally {
              submitDepositButton.disabled = false;
              submitDepositButton.textContent = "충전 신청하기";
            }
          });
        }

        // 알림 표시 함수
        function showNotification(message, duration = 3000) {
          const notification = document.getElementById("notification");
          const notificationMessage = document.getElementById(
            "notificationMessage"
          );
          if (!notification || !notificationMessage) return;
          notificationMessage.textContent = message;
          notification.classList.remove("hidden");
          setTimeout(() => {
            notification.classList.add("hidden");
          }, duration);
        }

        // 환전 신청 완료 모달 표시 함수
        function showExchangeRequestModal(requestAmount, newBalance) {
          if (modalRequestAmount)
            modalRequestAmount.textContent = `${requestAmount.toLocaleString()}원`;
          if (modalDeductedAmount)
            modalDeductedAmount.textContent = `${requestAmount.toLocaleString()}원`;
          if (modalCurrentBalance)
            modalCurrentBalance.textContent = `${newBalance.toLocaleString()}원`;
          if (exchangeRequestModal)
            exchangeRequestModal.classList.remove("hidden");
        }

        // 환전 완료 모달 닫기 이벤트
        if (closeExchangeRequestModal) {
          closeExchangeRequestModal.addEventListener("click", () => {
            if (exchangeRequestModal)
              exchangeRequestModal.classList.add("hidden");
          });
        }

        // 환전 완료 모달 외부 클릭 시 닫기
        if (exchangeRequestModal) {
          exchangeRequestModal.addEventListener("click", (e) => {
            if (e.target === exchangeRequestModal) {
              exchangeRequestModal.classList.add("hidden");
            }
          });
        }

        // 승리 모달 표시 함수

        // fetchUserInfo 디바운싱을 위한 변수
        let fetchUserInfoTimer = null;
        let fetchUserInfoInProgress = false;

        // 사용자 정보 가져오기 (디바운싱 적용)
        async function fetchUserInfo(immediate = false) {
          // 즉시 실행이 아닌 경우 디바운싱 적용
          if (!immediate) {
            if (fetchUserInfoTimer) {
              clearTimeout(fetchUserInfoTimer);
            }
            fetchUserInfoTimer = setTimeout(() => {
              fetchUserInfo(true);
            }, 200); // 200ms 디바운싱
            return;
          }

          // 이미 요청 중이면 중복 요청 방지
          if (fetchUserInfoInProgress) {
            return;
          }

          fetchUserInfoInProgress = true;

          try {
            const res = await fetch(
              "https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/auth/user-info",
              {
                headers: { Authorization: `Bearer ${token}` },
              }
            );
            if (res.ok) {
              const user = await res.json();
              const coinBalanceEl = document.getElementById("coinBalance");

              const balance =
                typeof user.balance === "number" && !isNaN(user.balance)
                  ? user.balance
                  : 0;
              const totalBets =
                typeof user.totalBets === "number" && !isNaN(user.totalBets)
                  ? user.totalBets
                  : 0;
              const rollingDeposit =
                typeof user.rollingDeposit === "number"
                  ? user.rollingDeposit
                  : 0;
              const rollingWagered =
                typeof user.rollingWagered === "number"
                  ? user.rollingWagered
                  : 0;
              const maxExchangeAmount =
                typeof user.maxExchangeAmount === "number"
                  ? user.maxExchangeAmount
                  : 0;

              if (coinBalanceEl)
                coinBalanceEl.innerText = `잔액: ${balance.toLocaleString()}원`;

              // 환전 모달에도 잔액 업데이트
              if (modalCoinBalance) {
                modalCoinBalance.textContent = `${balance.toLocaleString()}원`;
              }
              if (modalCoinBalance2) {
                modalCoinBalance2.textContent = `${balance.toLocaleString()}원`;
              }
              // 환전 모달 롤링 정보 업데이트
              if (rollingInfoDiv) {
                const rollingRequirement = rollingDeposit * 1.5;
                const progress =
                  rollingRequirement > 0
                    ? (rollingWagered / rollingRequirement) * 100
                    : 100;

                const progressTextEl = document.getElementById(
                  "rollingProgressText"
                );
                const progressBarEl =
                  document.getElementById("rollingProgressBar");
                const wageredTextEl =
                  document.getElementById("rollingWageredText");
                const requirementTextEl = document.getElementById(
                  "rollingRequirementText"
                );

                if (progressTextEl)
                  progressTextEl.textContent = `${Math.min(
                    100,
                    progress
                  ).toFixed(1)}%`;
                if (progressBarEl)
                  progressBarEl.style.width = `${Math.min(100, progress)}%`;
                if (wageredTextEl)
                  wageredTextEl.textContent = `${rollingWagered.toLocaleString()}원`;
                if (requirementTextEl)
                  requirementTextEl.textContent = `${rollingRequirement.toLocaleString()}원`;

                // 환전 가능 금액 표시 추가
                const maxExchangeEl =
                  document.getElementById("maxExchangeAmount");
                if (maxExchangeEl)
                  maxExchangeEl.textContent = `${maxExchangeAmount.toLocaleString()}원`;

                // 환전 버튼 활성화/비활성화 로직
                const amountInputVal = parseInt(exchangeAmountInput.value);
                const isAmountValid =
                  !isNaN(amountInputVal) &&
                  amountInputVal >= 5000 &&
                  amountInputVal <= maxExchangeAmount &&
                  maxExchangeAmount > 0;

                if (isAmountValid) {
                  submitExchangeButton.disabled = false;
                } else {
                  submitExchangeButton.disabled = true;
                }

                // 롤링 미달성 시 안내 메시지 표시
                if (
                  maxExchangeAmount === 0 &&
                  rollingRequirement > rollingWagered
                ) {
                  const remainingRolling = rollingRequirement - rollingWagered;
                  const maxExchangeEl =
                    document.getElementById("maxExchangeAmount");
                  if (maxExchangeEl)
                    maxExchangeEl.innerHTML = `0원 <span class="text-red-400 text-sm">(${remainingRolling.toLocaleString()}원 더 베팅 필요)</span>`;
                }
              }

              displayBettingHistory(user.bettingHistory);
              updateMyInfoModal(user);
            } else {
              showNotification("사용자 정보를 가져오는 데 실패했습니다.");
            }
          } catch (err) {
            // 에러
            showNotification("서버 연결 오류가 발생했습니다.");
          } finally {
            fetchUserInfoInProgress = false;
          }
        }

        // 내 정보 모달 탭 전환 기능
        function switchMyInfoTab(activeTab) {
          // 모든 탭 버튼 초기화
          const tabs = ["overviewTab", "bettingTab", "financialTab"];
          const contents = [
            "overviewContent",
            "bettingContent",
            "financialContent",
          ];

          tabs.forEach((tabId) => {
            const tab = document.getElementById(tabId);
            if (tab) {
              tab.className =
                "flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors text-gray-400 hover:text-yellow-500";
            }
          });

          contents.forEach((contentId) => {
            const content = document.getElementById(contentId);
            if (content) content.classList.add("hidden");
          });

          // 활성 탭 설정
          const activeTabElement = document.getElementById(activeTab + "Tab");
          const activeContentElement = document.getElementById(
            activeTab + "Content"
          );

          if (activeTabElement) {
            activeTabElement.className =
              "flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors golden-btn";
          }
          if (activeContentElement) {
            activeContentElement.classList.remove("hidden");
          }
        }

        // 상세 사용자 정보 가져오기 함수
        async function fetchDetailedUserInfo() {
          try {
            // 상세 사용자 정보 요청 시작
            const res = await fetch(
              "https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/users/detailed-info",
              {
                headers: { Authorization: `Bearer ${token}` },
              }
            );
            if (res.ok) {
              const data = await res.json();
              // 상세 사용자 정보 응답 및 베팅 통계
              updateDetailedMyInfoModal(data);
            } else {
              // API 응답 오류
              showNotification("상세 정보를 가져오는 데 실패했습니다.");
            }
          } catch (err) {
            console.error("상세 정보 조회 에러:", err);
            showNotification("서버 연결 오류가 발생했습니다.");
          }
        }

        // 상세 내 정보 모달 업데이트 함수
        function updateDetailedMyInfoModal(data) {
          // 계정 정보
          const userInfoName = document.getElementById("userInfoName");
          const userInfoJoinDate = document.getElementById("userInfoJoinDate");
          const userInfoLastLogin =
            document.getElementById("userInfoLastLogin");
          const userInfoStatus = document.getElementById("userInfoStatus");

          if (userInfoName) userInfoName.textContent = data.username || "-";
          if (userInfoJoinDate) {
            const joinDate = data.createdAt
              ? new Date(data.createdAt).toLocaleDateString()
              : "-";
            userInfoJoinDate.textContent = joinDate;
          }
          if (userInfoLastLogin) {
            const lastLogin = data.lastLogin
              ? new Date(data.lastLogin).toLocaleString()
              : "현재 접속중";
            userInfoLastLogin.textContent = lastLogin;
          }
          if (userInfoStatus) {
            userInfoStatus.textContent = data.isApproved ? "승인됨" : "미승인";
            userInfoStatus.className = data.isApproved
              ? "text-green-400 font-semibold"
              : "text-red-400 font-semibold";
          }

          // 게임 통계
          const userWins = document.getElementById("userWins");
          const userLoses = document.getElementById("userLoses");
          const userWinRateEl = document.getElementById("userWinRate");
          const totalGamesEl = document.getElementById("totalGames");
          const gameStatsBettingProfit = document.getElementById(
            "gameStatsBettingProfit"
          );

          if (userWins) userWins.textContent = data.gameStats.wins;
          if (userLoses) userLoses.textContent = data.gameStats.losses;
          if (userWinRateEl)
            userWinRateEl.textContent = `${data.gameStats.winRate}%`;
          if (totalGamesEl)
            totalGamesEl.textContent = data.gameStats.totalGames;

          // 게임 통계에 베팅 손익 표시
          if (gameStatsBettingProfit) {
            const profit = data.bettingStats.bettingProfit;
            gameStatsBettingProfit.textContent = `${profit.toLocaleString()}원`;
            gameStatsBettingProfit.className =
              profit >= 0
                ? "font-bold text-lg text-green-400"
                : "font-bold text-lg text-red-400";
          }

          // 전체 손익
          const currentBalance = document.getElementById("currentBalance");
          const overallProfit = document.getElementById("overallProfit");

          if (currentBalance)
            currentBalance.textContent = `${data.balance.toLocaleString()}원`;
          if (overallProfit) {
            const profit = data.financialInfo.overallProfit;
            overallProfit.textContent = `${profit.toLocaleString()}원`;
            overallProfit.className =
              profit >= 0
                ? "font-bold text-lg text-green-400"
                : "font-bold text-lg text-red-400";
          }

          // 베팅 통계
          const totalBetAmount = document.getElementById("modalTotalBetAmount");
          const totalWinAmount = document.getElementById("modalTotalWinAmount");
          const bettingProfit = document.getElementById("modalBettingProfit");
          const averageBetAmount = document.getElementById(
            "modalAverageBetAmount"
          );

          if (totalBetAmount) {
            totalBetAmount.textContent = `${data.bettingStats.totalBetAmount.toLocaleString()}원`;
          } else {
            console.error("modalTotalBetAmount 요소를 찾을 수 없음");
          }
          if (totalWinAmount)
            totalWinAmount.textContent = `${data.bettingStats.totalWinAmount.toLocaleString()}원`;
          if (bettingProfit) {
            const profit = data.bettingStats.bettingProfit;
            bettingProfit.textContent = `${profit.toLocaleString()}원`;
            bettingProfit.className =
              profit >= 0
                ? "font-bold text-green-400"
                : "font-bold text-red-400";
          }
          if (averageBetAmount)
            averageBetAmount.textContent = `${data.bettingStats.averageBetAmount.toLocaleString()}원`;

          // 베팅 선호도
          updateChoicePreferences(
            data.choiceStats,
            data.gameStats.favoriteChoice
          );

          // 롤링 정보
          const rollingProgressTextInfo = document.getElementById(
            "rollingProgressTextInfo"
          );
          const rollingProgressBarInfo = document.getElementById(
            "rollingProgressBarInfo"
          );
          const rollingWageredAmount = document.getElementById(
            "rollingWageredAmount"
          );
          const rollingRequiredAmount = document.getElementById(
            "rollingRequiredAmount"
          );
          const rollingStatusText =
            document.getElementById("rollingStatusText");

          if (rollingProgressTextInfo)
            rollingProgressTextInfo.textContent = `${data.rollingInfo.rollingProgress}%`;
          if (rollingProgressBarInfo)
            rollingProgressBarInfo.style.width = `${data.rollingInfo.rollingProgress}%`;
          if (rollingWageredAmount)
            rollingWageredAmount.textContent = `${data.rollingInfo.rollingWagered.toLocaleString()}원`;
          if (rollingRequiredAmount)
            rollingRequiredAmount.textContent = `${data.rollingInfo.rollingRequirement.toLocaleString()}원`;

          // 롤링 상태 텍스트 업데이트
          if (rollingStatusText) {
            const isRollingComplete =
              data.rollingInfo.rollingWagered >=
              data.rollingInfo.rollingRequirement;
            if (isRollingComplete) {
              rollingStatusText.textContent =
                "✅ 롤링 달성 완료 - 전액 환전 가능";
              rollingStatusText.className =
                "text-xs text-green-400 mt-1 font-bold";
            } else {
              const remaining =
                data.rollingInfo.rollingRequirement -
                data.rollingInfo.rollingWagered;
              rollingStatusText.textContent = `❌ 롤링 미달성 - ${remaining.toLocaleString()}원 더 베팅 필요`;
              rollingStatusText.className = "text-xs text-red-400 mt-1";
            }
          }

          // 재정 정보
          const totalDeposited = document.getElementById("totalDeposited");
          const totalExchanged = document.getElementById("totalExchanged");
          const depositCount = document.getElementById("depositCount");
          const exchangeCount = document.getElementById("exchangeCount");

          if (totalDeposited)
            totalDeposited.textContent = `${data.financialInfo.totalDeposited.toLocaleString()}원`;
          if (totalExchanged)
            totalExchanged.textContent = `${data.financialInfo.totalExchanged.toLocaleString()}원`;
          if (depositCount)
            depositCount.textContent = data.financialInfo.depositCount;
          if (exchangeCount)
            exchangeCount.textContent = data.financialInfo.exchangeCount;

          // 최근 기록들
          updateRecentRecords(null, data.recentDeposits, data.recentExchanges);
        }

        // 베팅 선호도 차트 업데이트
        function updateChoicePreferences(choiceStats, favoriteChoice) {
          const choicePreferences =
            document.getElementById("choicePreferences");
          const favoriteChoiceEl = document.getElementById("favoriteChoice");

          if (!choicePreferences) return;

          const choiceNames = {
            player: "플레이어",
            banker: "뱅커",
            tie: "타이",
            player_pair: "P 페어",
            banker_pair: "B 페어",
          };

          const colors = {
            player: "bg-blue-500",
            banker: "bg-red-500",
            tie: "bg-green-500",
            player_pair: "bg-purple-500",
            banker_pair: "bg-orange-500",
          };

          const total = Object.values(choiceStats).reduce(
            (sum, count) => sum + count,
            0
          );

          choicePreferences.innerHTML = "";

          if (total === 0) {
            choicePreferences.innerHTML =
              '<div class="text-center text-gray-400 py-2">베팅 기록이 없습니다.</div>';
            if (favoriteChoiceEl) favoriteChoiceEl.textContent = "-";
            return;
          }

          Object.entries(choiceStats).forEach(([choice, count]) => {
            if (count > 0) {
              const percentage = ((count / total) * 100).toFixed(1);
              const div = document.createElement("div");
              div.className = "flex items-center justify-between";
              div.innerHTML = `
                <div class="flex items-center gap-2">
                  <div class="w-3 h-3 rounded ${colors[choice]}"></div>
                  <span class="text-sm">${choiceNames[choice]}</span>
                </div>
                <div class="text-sm">
                  <span class="text-gray-400">${count}회</span>
                  <span class="text-yellow-500 ml-1">(${percentage}%)</span>
                </div>
              `;
              choicePreferences.appendChild(div);
            }
          });

          if (favoriteChoiceEl && favoriteChoice) {
            favoriteChoiceEl.textContent = `${
              choiceNames[favoriteChoice.choice]
            } (${favoriteChoice.count}회)`;
          }
        }

        // 최근 기록들 업데이트
        function updateRecentRecords(
          recentBets,
          recentDeposits,
          recentExchanges
        ) {
          // 최근 충전 내역
          const recentDepositsEl = document.getElementById("recentDeposits");
          if (recentDepositsEl) {
            recentDepositsEl.innerHTML = "";

            if (recentDeposits.length === 0) {
              recentDepositsEl.innerHTML =
                '<div class="text-center text-gray-400 py-2">최근 충전 내역이 없습니다.</div>';
            } else {
              recentDeposits.forEach((deposit) => {
                const div = document.createElement("div");
                div.className = "bg-black bg-opacity-30 p-3 rounded-lg";

                const statusClass = {
                  pending: "text-yellow-500",
                  approved: "text-green-500",
                  rejected: "text-red-500",
                }[deposit.status];

                const statusText = {
                  pending: "대기중",
                  approved: "승인됨",
                  rejected: "거절됨",
                }[deposit.status];

                div.innerHTML = `
                  <div class="flex justify-between items-center mb-1">
                    <span class="text-xs text-gray-400">${new Date(
                      deposit.createdAt
                    ).toLocaleString()}</span>
                    <span class="${statusClass} font-bold text-sm">${statusText}</span>
                  </div>
                  <div class="text-center">
                    <span class="text-blue-400 font-bold">${deposit.amount.toLocaleString()}원</span>
                  </div>
                `;
                recentDepositsEl.appendChild(div);
              });
            }
          }

          // 최근 환전 내역
          const recentExchangesEl = document.getElementById("recentExchanges");
          if (recentExchangesEl) {
            recentExchangesEl.innerHTML = "";

            if (recentExchanges.length === 0) {
              recentExchangesEl.innerHTML =
                '<div class="text-center text-gray-400 py-2">최근 환전 내역이 없습니다.</div>';
            } else {
              recentExchanges.forEach((exchange) => {
                const div = document.createElement("div");
                div.className = "bg-black bg-opacity-30 p-3 rounded-lg";

                const statusClass = {
                  pending: "text-yellow-500",
                  approved: "text-green-500",
                  rejected: "text-red-500",
                }[exchange.status];

                const statusText = {
                  pending: "대기중",
                  approved: "승인됨",
                  rejected: "거절됨",
                }[exchange.status];

                div.innerHTML = `
                  <div class="flex justify-between items-center mb-1">
                    <span class="text-xs text-gray-400">${new Date(
                      exchange.createdAt
                    ).toLocaleString()}</span>
                    <span class="${statusClass} font-bold text-sm">${statusText}</span>
                  </div>
                  <div class="text-center">
                    <span class="text-orange-400 font-bold">${(
                      exchange.actualAmount || exchange.requestAmount
                    ).toLocaleString()}원</span>
                  </div>
                `;
                recentExchangesEl.appendChild(div);
              });
            }
          }
        }

        // 기존 내 정보 모달 업데이트 함수 (호환성 유지)
        function updateMyInfoModal(user) {
          // 기본 정보만 업데이트 (상세 정보는 fetchDetailedUserInfo에서 처리)
          const userWins = document.getElementById("userWins");
          const userLoses = document.getElementById("userLoses");
          const userWinRateEl = document.getElementById("userWinRate");
          const totalGamesEl = document.getElementById("totalGames");

          const bettingHistory = user.bettingHistory || [];
          const wins = bettingHistory.filter(
            (record) => record.result === "win"
          ).length;
          const loses = bettingHistory.filter(
            (record) => record.result === "lose"
          ).length;
          const totalGames = bettingHistory.length;
          const winRate =
            totalGames > 0 ? ((wins / totalGames) * 100).toFixed(1) : 0;

          if (userWins) userWins.textContent = wins;
          if (userLoses) userLoses.textContent = loses;
          if (userWinRateEl) userWinRateEl.textContent = `${winRate}%`;
          if (totalGamesEl) totalGamesEl.textContent = totalGames;
        }

        // 베팅 기록 표시 함수 수정
        function displayBettingHistory(history) {
          const container = document.getElementById("bettingHistory");
          if (!container) return;
          container.innerHTML = "";
          container.scrollTop = 0;

          if (!history || history.length === 0) {
            container.innerHTML = `<div class="text-center text-gray-400 py-4">베팅 기록이 없습니다.</div>`;
            const winRateEl = document.getElementById("winRate");
            if (winRateEl) winRateEl.textContent = `승률: 0%`;
            return;
          }

          const totalBets = history.length;
          const wins = history.filter(
            (record) => record.result === "win"
          ).length;
          const winRateValue =
            totalBets > 0 ? ((wins / totalBets) * 100).toFixed(1) : 0;
          const winRateEl = document.getElementById("winRate");
          if (winRateEl) winRateEl.textContent = `승률: ${winRateValue}%`;

          history
            .slice()
            .reverse()
            .forEach((record) => {
              const card = document.createElement("div");
              card.className = "betting-history-card";
              const resultClass =
                record.result === "win"
                  ? "text-green-400"
                  : record.result === "lose"
                  ? "text-red-400"
                  : "text-yellow-400";
              const resultText =
                record.result === "win"
                  ? "승리"
                  : record.result === "lose"
                  ? "패배"
                  : "환급";
              const choiceKorean = {
                player: "플레이어",
                banker: "뱅커",
                tie: "타이",
                player_pair: "P 페어",
                banker_pair: "B 페어",
                null: "없음",
              };

              const displayAmount = (
                typeof record.amount === "number" ? record.amount : 0
              ).toLocaleString();
              let displayDate = "날짜 정보 없음";
              if (record.date) {
                try {
                  displayDate = new Date(record.date).toLocaleString();
                } catch (e) {
                  console.error(
                    "Invalid date format in betting history:",
                    record.date,
                    e
                  );
                  displayDate = "잘못된 날짜 형식";
                }
              } else {
                console.warn("Missing date in betting history record:", record);
              }

              card.innerHTML = `
              <div class="flex justify-between items-center mb-1">
                <span class="text-sm text-gray-400">${displayDate}</span>
                <span class="font-bold ${resultClass}">${resultText}</span>
              </div>
              <div class="flex justify-between items-center">
                <span>${
                  choiceKorean[record.choice] || record.choice || "선택 없음"
                } → ${
                choiceKorean[record.gameResult] ||
                record.gameResult ||
                "결과 없음"
              }</span>
                <span class="text-yellow-400 font-bold">${displayAmount} 원</span>
              </div>`;
              container.appendChild(card);
            });
        }

        // 선택 상태 업데이트 함수 수정
        function updateCurrentBet() {
          const choiceKorean = {
            player: "플레이어",
            banker: "뱅커",
            tie: "타이",
            player_pair: "P 페어",
            banker_pair: "B 페어",
            null: "없음",
          };
          const choiceText = document.querySelector("#currentBet .choice-text");
          const coinsText = document.querySelector("#currentBet .coins-text");

          if (choiceText)
            choiceText.textContent = choiceKorean[selectedChoice] || "없음";
          if (coinsText)
            coinsText.textContent = `${selectedChipAmount.toLocaleString()}원`;

          document.querySelectorAll(".choice-button").forEach((btn) => {
            if (btn.getAttribute("data-choice") === selectedChoice)
              btn.classList.add("active");
            else btn.classList.remove("active");
          });

          document.querySelectorAll(".amount-button").forEach((btn) => {
            if (
              parseInt(btn.getAttribute("data-amount")) === selectedChipAmount
            ) {
              btn.classList.add("active");
            } else {
              btn.classList.remove("active");
            }
          });
        }

        // 나가기 기능
        document.getElementById("logout")?.addEventListener("click", () => {
          window.location.href = "index.html";
        });

        // 베팅 종류 버튼 클릭 이벤트 수정: 선택 및 즉시 베팅
        document.querySelectorAll(".choice-button").forEach((button) => {
          button.addEventListener("click", async () => {
            // 베팅 처리 중이면 무시
            if (isBettingInProgress) {
              return;
            }

            if (!bettingActive) {
              showNotification("현재 베팅 시간이 아닙니다.");
              return;
            }

            selectedChoice = button.getAttribute("data-choice");
            if (!selectedChoice) {
              showNotification("베팅 종류를 선택해주세요.");
              return;
            }
            if (selectedChipAmount <= 0) {
              showNotification("베팅할 금액을 먼저 선택해주세요.");
              updateCurrentBet();
              return;
            }

            // 뱅커/플레이어 베팅 제한 체크
            if (selectedChoice === "player" || selectedChoice === "banker") {
              const oppositeChoice =
                selectedChoice === "player" ? "banker" : "player";
              if (
                currentBets[oppositeChoice] &&
                currentBets[oppositeChoice] > 0
              ) {
                showNotification(
                  `${
                    oppositeChoice === "player" ? "플레이어" : "뱅커"
                  }에 이미 베팅하셨습니다. 뱅커와 플레이어 중 한 곳에만 베팅할 수 있습니다.`
                );
                return;
              }
            }

            // 베팅 처리 시작
            isBettingInProgress = true;

            // 버튼에 로딩 효과 추가
            button.classList.add("opacity-50", "pointer-events-none");
            const originalContent = button.innerHTML;
            const loadingSpinner = document.createElement("div");
            loadingSpinner.className =
              "absolute inset-0 flex items-center justify-center";
            loadingSpinner.innerHTML =
              '<i class="fas fa-spinner fa-spin text-white text-2xl"></i>';
            button.style.position = "relative";
            button.appendChild(loadingSpinner);

            // 베팅 정보 저장
            lastBetChoice = selectedChoice;
            lastBetAmount = selectedChipAmount;

            socket.emit("place_bet", {
              choice: selectedChoice,
              amount: selectedChipAmount,
              token: token,
            });

            // 응답 대기 (타임아웃 설정)
            setTimeout(() => {
              if (isBettingInProgress) {
                isBettingInProgress = false;
                button.classList.remove("opacity-50", "pointer-events-none");
                button.removeChild(loadingSpinner);
              }
            }, 3000); // 3초 타임아웃

            updateCurrentBet();
          });
        });

        // 금액 버튼 클릭 이벤트 수정: 단일 칩 금액 선택
        document.querySelectorAll(".amount-button").forEach((button) => {
          button.addEventListener("click", () => {
            const chipValue = parseInt(button.getAttribute("data-amount"));
            if (selectedChipAmount === chipValue) {
              selectedChipAmount = 0;
            } else {
              selectedChipAmount = chipValue;
            }
            updateCurrentBet();
          });
        });

        // 되돌리기 버튼 이벤트 수정: 마지막 베팅 취소 요청
        document
          .getElementById("undoBetButton")
          ?.addEventListener("click", () => {
            if (!bettingActive) {
              showNotification("베팅 시간이 아니므로 되돌릴 수 없습니다."); // 중요 알림 유지 및 문구 수정
              return;
            }
            // 서버에 마지막 베팅 취소 요청
            socket.emit("cancel_bet", { token: token });
          });

        // 최근 게임 결과 가져오기 함수 (새로운 스코어보드 로직 사용)
        async function fetchRecentGames() {
          try {
            const res = await fetch(
              "https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/recent-games"
            );
            const games = await res.json();

            // 통계 카운트
            let playerCount = 0;
            let bankerCount = 0;
            let tieCount = 0;

            if (games.length === 0) {
              updateGameCounts(0, 0, 0);
              // 빈 스코어보드 렌더링
              updateScoreboard([]);
              return;
            }

            // 통계 계산
            games.forEach((game) => {
              if (game.result === "player") playerCount++;
              else if (game.result === "banker") bankerCount++;
              else if (game.result === "tie") tieCount++;
            });

            // 통계 업데이트
            updateGameCounts(playerCount, bankerCount, tieCount);

            // 서버 데이터를 새로운 스코어보드 함수에 맞는 형식으로 변환
            const historyForScoreboard = games.reverse().map((game) => ({
              winner: game.result,
              pair: game.playerPairOccurred
                ? "p"
                : game.bankerPairOccurred
                ? "b"
                : null,
            }));

            // 새로운 스코어보드 함수 호출
            updateScoreboard(historyForScoreboard);

            // 스크롤을 맨 오른쪽으로
            const container = document.getElementById("recentResults");
            if (container) {
              container.scrollLeft = container.scrollWidth;
            }
          } catch (err) {
            console.error("최근 게임 결과 조회 에러:", err);
          }
        }

        // 게임 카운트 업데이트 함수
        function updateGameCounts(playerCount, bankerCount, tieCount) {
          const playerCountEl = document.getElementById("playerCount");
          const bankerCountEl = document.getElementById("bankerCount");
          const tieCountEl = document.getElementById("tieCount");

          if (playerCountEl) playerCountEl.textContent = playerCount;
          if (bankerCountEl) bankerCountEl.textContent = bankerCount;
          if (tieCountEl) tieCountEl.textContent = tieCount;
        }

        // Socket.IO 이벤트 핸들러들
        socket.on("bet_success", (data) => {
          // 베팅 처리 완료
          isBettingInProgress = false;

          // 모든 베팅 버튼의 로딩 상태 해제
          document.querySelectorAll(".choice-button").forEach((btn) => {
            btn.classList.remove("opacity-50", "pointer-events-none");
            const spinner = btn.querySelector(".fa-spinner");
            if (spinner && spinner.parentElement) {
              btn.removeChild(spinner.parentElement);
            }
          });

          // showNotification(message); // "베팅이 완료되었습니다." 알림 제거됨
          if (data.newBalance !== undefined) {
            // 서버에서 새 잔액을 보내준 경우 즉시 업데이트
            const coinBalanceEl = document.getElementById("coinBalance");
            if (coinBalanceEl) {
              coinBalanceEl.textContent = `잔액: ${data.newBalance.toLocaleString()}원`;
            }
          } else {
            // 기존 방식으로 전체 정보 다시 가져오기
            fetchUserInfo(); // 잔액 업데이트
          }
        });

        socket.on("bet_cancelled_success", (data) => {
          // showNotification(data.message); // "베팅(선택: X, 금액: Y)이 취소되었습니다." 알림 제거
          if (data.newBalance !== undefined) {
            // 서버에서 새 잔액을 보내준 경우 즉시 업데이트
            const coinBalanceEl = document.getElementById("coinBalance");
            if (coinBalanceEl) {
              coinBalanceEl.textContent = `보유금액: ${data.newBalance.toLocaleString()}원`;
            }
          } else {
            fetchUserInfo(); // 잔액 즉시 업데이트
          }
          // 현재 선택된 칩/종류는 그대로 두거나, 취소된 베팅에 맞춰 UI를 조정할 수도 있습니다.
          // 예를 들어, 취소된 베팅과 동일한 선택이었다면 UI 선택도 해제하는 것을 고려할 수 있습니다.
          // 지금은 단순히 잔액만 업데이트합니다.
          updateCurrentBet(); // 현재 선택 상태(selectedChipAmount, selectedChoice)에 따른 UI 업데이트
        });

        socket.on("error", (message) => {
          console.log(
            "현재 표시된 잔액:",
            document.getElementById("coinBalance")?.textContent
          );

          // 베팅 처리 완료 (에러 발생)
          isBettingInProgress = false;

          // 모든 베팅 버튼의 로딩 상태 해제
          document.querySelectorAll(".choice-button").forEach((btn) => {
            btn.classList.remove("opacity-50", "pointer-events-none");
            const spinner = btn.querySelector(".fa-spinner");
            if (spinner && spinner.parentElement) {
              btn.removeChild(spinner.parentElement);
            }
          });

          showNotification(message);
        });

        socket.on("betting_started", () => {
          // 이미 베팅이 활성화되어 있으면 중복 처리 방지
          if (bettingActive) {
            console.log('베팅이 이미 활성화되어 있습니다. 중복 처리 방지');
            return;
          }
          
          bettingActive = true;
          
          // 새 게임 시작 시 베팅 상황 초기화
          currentBets = {};
          
          const timerEl = document.getElementById("timer");
          if (timerEl) timerEl.innerText = "베팅이 시작되었습니다.";
          const bettingStartSound =
            document.getElementById("bettingStartSound");
          bettingStartSound?.play().catch((err) => {});

          // 새 베팅 라운드 시작시에만 UI 선택 초기화 (마지막 베팅 정보는 유지)
          selectedChoice = null;
          // selectedChipAmount = 0; // 베팅 금액은 유지
          updateCurrentBet();
          
          // 베팅 UI 활성화
          enableBettingUI();
        });

        socket.on("betting_end_time", (endTime) => {
          startTimer(new Date(endTime));
        });

        function startTimer(endTime) {
          const timerElement = document.getElementById("timer");
          if (!timerElement) return;

          // 이미 베팅이 활성화되어 있고 타이머가 실행 중이면 중복 실행 방지
          if (bettingActive && window.bettingTimerInterval) {
            console.log('타이머가 이미 실행 중입니다. 중복 실행 방지');
            return;
          }

          // 기존 타이머가 있으면 정리
          if (window.bettingTimerInterval) {
            clearInterval(window.bettingTimerInterval);
          }

          // 베팅 상태 활성화
          bettingActive = true;

          window.bettingTimerInterval = setInterval(() => {
            const now = new Date();
            const distance = endTime - now;
            if (distance < 0) {
              clearInterval(window.bettingTimerInterval);
              bettingActive = false;
              timerElement.innerText =
                "베팅 시간이 종료되었습니다. 결과를 기다려주세요.";
              timerElement.className = "text-red-500 font-bold";
              selectedChoice = null;
              // selectedChipAmount = 0; // 베팅 금액은 유지
              updateCurrentBet();
              disableBettingUI();
              return;
            }
            const seconds = Math.floor((distance / 1000) % 60);
            timerElement.innerText = `베팅 종료까지: ${seconds}초`;
            if (seconds <= 10)
              timerElement.className = "text-red-500 font-bold animate-pulse";
            else
              timerElement.className =
                "text-base font-semibold text-yellow-400";
          }, 1000);
        }

        socket.on("betting_closed", () => {
          bettingActive = false;
          isBettingInProgress = false; // 베팅 진행 중 플래그 초기화

          // 모든 베팅 버튼의 로딩 상태 해제 (혹시 남아있을 경우)
          document.querySelectorAll(".choice-button").forEach((btn) => {
            btn.classList.remove("opacity-50", "pointer-events-none");
            const spinner = btn.querySelector(".fa-spinner");
            if (spinner && spinner.parentElement) {
              btn.removeChild(spinner.parentElement);
            }
          });

          const timerEl = document.getElementById("timer");
          if (timerEl)
            timerEl.innerText =
              "베팅 시간이 종료되었습니다. 결과를 기다려주세요.";
          const bettingEndSound = document.getElementById("bettingEndSound");
          bettingEndSound?.play().catch((err) => {});
          // selectedChoice와 selectedChipAmount는 게임 결과 처리 후에 초기화
          // selectedChoice = null;
          // selectedChipAmount = 0;
          updateCurrentBet();
          
          // 베팅 UI 비활성화
          disableBettingUI();
        });

        socket.on("game_result", (data) => {
          const {
            result,
            playerScore,
            bankerScore,
            // playerPairOccurred, // 미니게임에서는 페어 직접 표시 안함 (recentResults에서 확인)
            // bankerPairOccurred,
          } = data;
          let soundId = "";

          if (result === "player") {
            soundId = "playerWinSound";
          } else if (result === "banker") {
            soundId = "bankerWinSound";
          } else {
            soundId = "tieSound";
          }
          document
            .getElementById(soundId)
            ?.play()
            .catch((err) => {});

          // 미니게임에도 결과 표시
          try {
            if (baccaratSceneMini && baccaratSceneMini.sys && baccaratSceneMini.sys.isActive() && !baccaratSceneMini.sys.isDestroyed) {
              if (typeof baccaratSceneMini.setGameResult === 'function') {
                baccaratSceneMini.setGameResult(result, playerScore, bankerScore);
              }
            }
          } catch (error) {
            console.warn("[MiniGame] Error setting game result:", error);
          }

          const timerEl = document.getElementById("timer");
          if (timerEl) {
            timerEl.innerText = "결과 발표 중... (2초 후 초기화)";
            timerEl.className =
              "text-base font-semibold text-yellow-400 bg-black bg-opacity-50 inline-block px-3 py-1 rounded-lg border border-[#b8860b]";

            // 카운트다운 표시
            let countdown = 2;
            const countdownInterval = setInterval(() => {
              countdown--;
              if (countdown > 0) {
                timerEl.innerText = `결과 발표 중... (${countdown}초 후 초기화)`;
              } else {
                clearInterval(countdownInterval);
              }
            }, 1000);
          }
          // 최근 결과 업데이트는 result_approved에서 처리하므로 여기서는 중복 호출 방지
          // fetchRecentGames(); // 이 부분은 result_approved로 이동 또는 거기서만 호출
        });

        socket.on("result_approved", (data) => {
          // 게임 결과를 즉시 초기화
          setTimeout(() => {
            fetchUserInfo();
            fetchRecentGames(); // 결과 승인 후 최근 게임 목록 업데이트

            // 예측 결과 확인 및 제거
            if (currentPrediction) {
              removePrediction();
            }

            // gameStatus 제거됨
            const timerEl = document.getElementById("timer");
            if (timerEl) {
              timerEl.textContent = "";
              timerEl.className = "text-base font-semibold text-yellow-400";
            }
            // 베팅 정보 완전 초기화
            // selectedChipAmount = 0; // 베팅 금액은 유지
            selectedChoice = null;
            lastBetChoice = null;
            lastBetAmount = 0;
            isBettingInProgress = false; // 베팅 진행 중 플래그 초기화
            previousStats = {}; // 이전 통계 초기화
            updateCurrentBet();
            updateMyBetAmounts({}); // 내 베팅액 표시 초기화 (총 베팅 금액도 함께 초기화됨)

            // 미니게임 클리어
            try {
              if (baccaratSceneMini && baccaratSceneMini.sys && baccaratSceneMini.sys.isActive() && !baccaratSceneMini.sys.isDestroyed) {
                if (typeof baccaratSceneMini.clearAllCardsAndText === 'function') {
                  baccaratSceneMini.clearAllCardsAndText();
                }
              }
            } catch (error) {
              console.warn("[MiniGame] Error clearing cards and text:", error);
            }

            updateBettingStatsDisplay({
              player: {
                count: 0,
                total: 0,
                bettor_count: 0,
                total_bet_amount: 0,
              },
              banker: {
                count: 0,
                total: 0,
                bettor_count: 0,
                total_bet_amount: 0,
              },
              tie: { count: 0, total: 0, bettor_count: 0, total_bet_amount: 0 },
              player_pair: {
                count: 0,
                total: 0,
                bettor_count: 0,
                total_bet_amount: 0,
              },
              banker_pair: {
                count: 0,
                total: 0,
                bettor_count: 0,
                total_bet_amount: 0,
              },
            });
          }, 200); // 0.2초 후 초기화
        });

        socket.on("update_coins", () => {
          fetchUserInfo();
        });

        // 관리자 잔액 조정 시 실시간 업데이트
        socket.on("balance_updated", (data) => {
          // 데이터 유효성 검사
          if (!data || typeof data.newBalance === 'undefined' || data.newBalance === null) {
            return;
          }

          const coinBalanceEl = document.getElementById("coinBalance");
          if (coinBalanceEl) {
            coinBalanceEl.textContent = `잔액: ${data.newBalance.toLocaleString()}원`;
          }
          // 환전 모달에도 업데이트
          const modalCoinBalance = document.getElementById("modalCoinBalance");
          const modalCoinBalance2 =
            document.getElementById("modalCoinBalance2");
          if (modalCoinBalance) {
            modalCoinBalance.textContent = `${data.newBalance.toLocaleString()}원`;
          }
          if (modalCoinBalance2) {
            modalCoinBalance2.textContent = `${data.newBalance.toLocaleString()}원`;
          }
          showNotification("관리자가 잔액을 조정했습니다.");
        });

        // 충전 요청 처리 알림
        socket.on("deposit_request_processed", (data) => {
          // 데이터 유효성 검사
          if (!data || typeof data.amount === 'undefined' || data.amount === null) {
            console.error('Invalid deposit_request_processed data:', data);
            showNotification("충전 처리 알림을 받는 중 오류가 발생했습니다.");
            return;
          }

          if (data.status === "approved") {
            showNotification(
              `충전이 승인되었습니다! +${data.amount.toLocaleString()}원`
            );
            // 내 정보 모달이 열려있다면 새로고침
            if (!myInfoModal.classList.contains("hidden")) {
              fetchDetailedUserInfo();
            }
          } else {
            showNotification(
              `충전 요청이 거절되었습니다. (${data.amount.toLocaleString()}원)`
            );
          }
        });

        // 환전 요청 처리 알림
        socket.on("exchange_request_processed", (data) => {
          // 데이터 유효성 검사
          if (!data) {
            console.error('Invalid exchange_request_processed data:', data);
            showNotification("환전 처리 알림을 받는 중 오류가 발생했습니다.");
            return;
          }

          if (data.status === "approved") {
            const actualAmount = data.actualAmount || 0;
            showNotification(
              `환전이 승인되었습니다! 실수령액: ${actualAmount.toLocaleString()}원`
            );
            // 내 정보 모달이 열려있다면 새로고침
            if (!myInfoModal.classList.contains("hidden")) {
              fetchDetailedUserInfo();
            }
          } else {
            const requestAmount = data.requestAmount || 0;
            showNotification(
              `환전 요청이 거절되었습니다. (신청액: ${requestAmount.toLocaleString()}원)`
            );
          }
        });

        // 송금 받았을 때 알림
        socket.on("money_received", (data) => {
          // 데이터 유효성 검사
          if (!data || typeof data.amount === 'undefined' || data.amount === null || !data.fromUsername) {
            console.error('Invalid money_received data:', data);
            showNotification("송금 알림을 받는 중 오류가 발생했습니다.");
            return;
          }

          showNotification(
            `${
              data.fromUsername
            }님으로부터 ${data.amount.toLocaleString()}원을 받았습니다!`
          );
          fetchUserInfo();
        });

        // 송금 보냈을 때 알림
        socket.on("money_sent", (data) => {
          // 데이터 유효성 검사
          if (!data || typeof data.amount === 'undefined' || data.amount === null || !data.toUsername) {
            console.error('Invalid money_sent data:', data);
            showNotification("송금 완료 알림을 받는 중 오류가 발생했습니다.");
            return;
          }

          const fee = data.fee || 0;
          showNotification(
            `${
              data.toUsername
            }님에게 ${data.amount.toLocaleString()}원을 송금했습니다. (수수료: ${fee.toLocaleString()}원)`
          );
        });

        // 승리 알림 수신
        socket.on("you_won", (data) => {
          // 거의 바로 승리 메시지 표시
          setTimeout(() => {
            showWinMessage(data.winnings);
          }, 50);
        });

        // 송금 내역 업데이트 신호
        socket.on("transfer_history_updated", () => {
          // 뽀찌 탭이 열려있고 내역보기가 활성화되어 있다면 새로고침
          if (
            !chargeExchangeModal.classList.contains("hidden") &&
            transferContent &&
            !transferContent.classList.contains("hidden") &&
            !document
              .getElementById("transferHistorySection")
              .classList.contains("hidden")
          ) {
            fetchTransferHistory();
          }
        });

        // 머니 요청 받았을 때 알림
        socket.on("money_request_received", (data) => {
          // 데이터 유효성 검사
          if (!data || typeof data.amount === 'undefined' || data.amount === null || !data.fromUsername) {
            console.error('Invalid money_request_received data:', data);
            showNotification("머니 요청 알림을 받는 중 오류가 발생했습니다.");
            return;
          }

          showNotification(
            `${
              data.fromUsername
            }님이 ${data.amount.toLocaleString()}원을 요청했습니다.`
          );
        });

        // 머니 요청 보냈을 때 알림
        socket.on("money_request_sent", (data) => {
          // 데이터 유효성 검사
          if (!data || typeof data.amount === 'undefined' || data.amount === null || !data.toUsername) {
            console.error('Invalid money_request_sent data:', data);
            showNotification("머니 요청 전송 알림을 받는 중 오류가 발생했습니다.");
            return;
          }

          showNotification(
            `${
              data.toUsername
            }님에게 ${data.amount.toLocaleString()}원을 요청했습니다.`
          );
        });

        // 받은 요청 목록 업데이트 신호
        socket.on("received_requests_updated", () => {
          // 뽀찌 탭이 열려있고 내역보기가 활성화되어 있다면 새로고침
          if (
            !chargeExchangeModal.classList.contains("hidden") &&
            transferContent &&
            !transferContent.classList.contains("hidden") &&
            !document
              .getElementById("transferHistorySection")
              .classList.contains("hidden")
          ) {
            fetchReceivedRequests();
          }
        });

        // 머니 요청이 수락되었을 때 알림
        socket.on("money_request_accepted", (data) => {
          // 데이터 유효성 검사
          if (!data || typeof data.amount === 'undefined' || data.amount === null || !data.acceptedByUsername) {
            console.error('Invalid money_request_accepted data:', data);
            showNotification("머니 요청 수락 알림을 받는 중 오류가 발생했습니다.");
            return;
          }

          showNotification(
            `${
              data.acceptedByUsername
            }님이 ${data.amount.toLocaleString()}원 요청을 수락했습니다!`
          );
          fetchUserInfo();
        });

        // 머니 요청 수락 완료 알림
        socket.on("money_request_accept_completed", (data) => {
          // 데이터 유효성 검사
          if (!data || typeof data.amount === 'undefined' || data.amount === null || !data.toUsername) {
            console.error('Invalid money_request_accept_completed data:', data);
            showNotification("머니 요청 수락 완료 알림을 받는 중 오류가 발생했습니다.");
            return;
          }

          const fee = data.fee || 0;
          showNotification(
            `${
              data.toUsername
            }님의 ${data.amount.toLocaleString()}원 요청을 수락했습니다. (수수료: ${fee.toLocaleString()}원)`
          );
        });

        // 머니 요청이 거절되었을 때 알림
        socket.on("money_request_rejected", (data) => {
          // 데이터 유효성 검사
          if (!data || typeof data.amount === 'undefined' || data.amount === null || !data.rejectedByUsername) {
            console.error('Invalid money_request_rejected data:', data);
            showNotification("머니 요청 거절 알림을 받는 중 오류가 발생했습니다.");
            return;
          }

          showNotification(
            `${
              data.rejectedByUsername
            }님이 ${data.amount.toLocaleString()}원 요청을 거절했습니다.`
          );
        });

        // 머니 요청 거절 완료 알림
        socket.on("money_request_reject_completed", (data) => {
          // 데이터 유효성 검사
          if (!data || typeof data.amount === 'undefined' || data.amount === null || !data.fromUsername) {
            console.error('Invalid money_request_reject_completed data:', data);
            showNotification("머니 요청 거절 완료 알림을 받는 중 오류가 발생했습니다.");
            return;
          }

          showNotification(
            `${
              data.fromUsername
            }님의 ${data.amount.toLocaleString()}원 요청을 거절했습니다.`
          );
        });

        // ===========================
        // 채팅 관련 Socket 이벤트들
        // ===========================

        // 새 채팅 메시지 수신
        socket.on("new_chat_message", (message) => {
          // 채팅창이 열려있으면 메시지 추가
          if (isChatOpen) {
            appendChatMessage(message);
            // 스크롤을 맨 아래로
            setTimeout(() => {
              if (chatMessages) {
                chatMessages.scrollTop = chatMessages.scrollHeight;
              }
            }, 100);
          } else {
            // 채팅창이 닫혀있으면 읽지 않은 메시지 카운트 증가
            unreadChatCount++;
            updateChatNotificationBadge();

            // 일반 메시지는 간단한 알림음만
            if (!message.isAdmin) {
              playNotificationSound();
            }
          }
        });

        // Admin 메시지 특별 알림
        socket.on("admin_message_notification", (data) => {
          const message = data.message;

          // Admin 메시지 알림 바 표시
          showMessageBar(message, false);

          // 특별한 알림음 (더 강한 소리)
          try {
            const audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Admin 메시지는 더 긴 알림음
            oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);
            oscillator.frequency.setValueAtTime(
              1200,
              audioContext.currentTime + 0.1
            );
            oscillator.frequency.setValueAtTime(
              800,
              audioContext.currentTime + 0.2
            );

            gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.5
            );

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
          } catch (err) {
            // 오디오 재생 실패 시 무시
          }

          // 채팅창이 닫혀있어도 Admin 메시지는 바로 추가
          if (!isChatOpen && chatMessages) {
            appendChatMessage(message);
          }
        });

        // 강조 메시지 특별 알림
        socket.on("highlight_message_notification", (data) => {
          const message = data.message;

          // 강조 메시지 알림 바 표시 (2초간)
          showMessageBar(message, true);

          // 강조 메시지 알림음
          try {
            const audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // 강조 메시지는 특별한 알림음
            oscillator.frequency.setValueAtTime(900, audioContext.currentTime);
            oscillator.frequency.setValueAtTime(
              1100,
              audioContext.currentTime + 0.1
            );
            oscillator.frequency.setValueAtTime(
              900,
              audioContext.currentTime + 0.2
            );

            gainNode.gain.setValueAtTime(0.12, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.3
            );

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
          } catch (err) {
            // 오디오 재생 실패 시 무시
          }

          // 채팅창이 닫혀있어도 강조 메시지는 바로 추가 (관리자 메시지와 동일)
          if (!isChatOpen && chatMessages) {
            const highlightMessage = {
              ...message,
              isHighlight: true,
            };
            appendChatMessage(highlightMessage);
          }
        });

        // 일반 강조 메시지 수신 (채팅창에 표시용)
        socket.on("highlight_message", (message) => {
          // 채팅창이 열려있으면 강조 메시지 추가
          if (isChatOpen) {
            const highlightMessage = {
              ...message,
              isHighlight: true,
            };
            appendChatMessage(highlightMessage);
            // 스크롤을 맨 아래로
            setTimeout(() => {
              if (chatMessages) {
                chatMessages.scrollTop = chatMessages.scrollHeight;
              }
            }, 100);
          } else {
            // 채팅창이 닫혀있으면 읽지 않은 메시지 카운트 증가
            unreadChatCount++;
            updateChatNotificationBadge();
          }
        });

        // 채팅 메시지 삭제 (관리자가 삭제한 경우)
        socket.on("chat_message_deleted", (data) => {
          const messageElements =
            chatMessages?.querySelectorAll(".chat-message");
          if (messageElements) {
            messageElements.forEach((el) => {
              // 메시지 ID로 찾아서 삭제 (실제로는 데이터 속성을 추가해야 하지만 간단하게 구현)
              // 여기서는 전체 채팅 기록을 다시 로드하는 방식으로 처리
            });
            // 채팅 기록 다시 로드
            if (isChatOpen) {
              loadChatHistory();
            }
          }
        });

        // 채팅 참여 신호
        socket.emit("join_chat");

        // 이전 통계 상태 저장 (변경 감지용)
        let previousStats = {};

        // 베팅 통계 표시 업데이트 함수 (최적화)
        function updateBettingStatsDisplay(stats) {
          // requestAnimationFrame을 사용하여 렌더링 최적화
          requestAnimationFrame(() => {
            const totalMainBetsCount =
              (stats.player?.count || 0) +
              (stats.banker?.count || 0) +
              (stats.tie?.count || 0);

            function formatAmount(amount) {
              if (amount >= 1000000) {
                return (amount / 1000000).toFixed(1).replace(".0", "") + "M";
              }
              if (amount >= 1000) {
                return (amount / 1000).toFixed(1).replace(".0", "") + "K";
              }
              return amount.toString();
            }

            function updateSection(sectionKey, statsData) {
              // 이전 값과 비교하여 변경된 경우에만 업데이트
              const prevData = previousStats[sectionKey] || {};
              const count = statsData?.count || 0;
              const totalAmount =
                statsData?.total_bet_amount || statsData?.total || 0;
              const bettorCount = statsData?.bettor_count || 0;

              // 변경 사항이 없으면 건너뛰기
              if (
                prevData.count === count &&
                prevData.totalAmount === totalAmount &&
                prevData.bettorCount === bettorCount &&
                prevData.totalMainBetsCount === totalMainBetsCount
              ) {
                return;
              }

              // 이전 값 저장
              previousStats[sectionKey] = {
                count,
                totalAmount,
                bettorCount,
                totalMainBetsCount,
              };

              const sectionElement = document.getElementById(
                `${sectionKey}Stats`
              );
              if (!sectionElement) return;

              const percentageElement =
                sectionElement.querySelector(".percentage-circle");
              const totalBetElement = sectionElement.querySelector(
                ".stats-details .total-bet"
              );
              const bettorCountElement = sectionElement.querySelector(
                ".stats-details .bettor-count"
              );

              let percentage = 0;

              if (percentageElement) {
                if (
                  totalMainBetsCount > 0 &&
                  (sectionKey === "player" ||
                    sectionKey === "banker" ||
                    sectionKey === "tie")
                ) {
                  percentage = ((count / totalMainBetsCount) * 100).toFixed(0);
                }
                const newText = `${percentage}%`;
                if (percentageElement.textContent !== newText) {
                  percentageElement.textContent = newText;
                }
              }

              if (totalBetElement) {
                const newText = `₩${formatAmount(totalAmount)}`;
                if (totalBetElement.textContent !== newText) {
                  totalBetElement.textContent = newText;
                }
              }

              if (bettorCountElement) {
                const newHTML = `<i class="fas fa-users"></i> ${bettorCount}`;
                if (bettorCountElement.innerHTML !== newHTML) {
                  bettorCountElement.innerHTML = newHTML;
                  bettorCountElement.classList.remove("hidden");
                }
              }
            }

            if (stats.player) updateSection("player", stats.player);
            if (stats.banker) updateSection("banker", stats.banker);
            if (stats.tie) updateSection("tie", stats.tie);
            if (stats.player_pair)
              updateSection("player_pair", stats.player_pair);
            if (stats.banker_pair)
              updateSection("banker_pair", stats.banker_pair);
          });
        }

        socket.on("betting_status", (status) => {
          bettingActive = status.active;
          if (status.stats) {
            updateBettingStatsDisplay(status.stats);
          }

          // 베팅이 활성화되어 있고 종료 시간이 있으면 타이머 시작
          if (status.active && status.endTime) {
            // gameStatus 제거됨

            const endTime = new Date(status.endTime);
            startTimer(endTime);

            // 내 베팅 정보 요청
            socket.emit("request_my_bets", token);
          }
        });

        // 배치 업데이트를 위한 변수
        let statsUpdateTimer = null;
        let pendingStatsUpdate = null;

        socket.on("new_bet", (data) => {
          if (data.stats) {
            // 배치 업데이트가 아닌 경우 디바운싱 적용
            if (!data.batchUpdate) {
              pendingStatsUpdate = data.stats;

              if (statsUpdateTimer) {
                clearTimeout(statsUpdateTimer);
              }

              statsUpdateTimer = setTimeout(() => {
                if (pendingStatsUpdate) {
                  updateBettingStatsDisplay(pendingStatsUpdate);
                  pendingStatsUpdate = null;
                }
              }, 50); // 50ms 디바운싱
            } else {
              // 배치 업데이트인 경우 즉시 적용
              updateBettingStatsDisplay(data.stats);
            }
          }
        });

        // ##### 내 베팅액 관련 로직 #####
        function updateMyBetAmounts(myBets) {
          const choices = [
            "player",
            "banker",
            "tie",
            "player_pair",
            "banker_pair",
          ];

          // 총 베팅 금액 계산
          let totalBetAmount = 0;
          choices.forEach((choice) => {
            const myBetEl = document.querySelector(
              `#${choice}Stats .my-bet-amount`
            );
            if (myBetEl) {
              const amount = myBets && myBets[choice] ? myBets[choice] : 0;
              totalBetAmount += amount;
              if (amount > 0) {
                myBetEl.textContent = `(${amount.toLocaleString()}원)`; // "내 베팅:" 텍스트 제거
                myBetEl.classList.remove("hidden");
              } else {
                myBetEl.textContent = "";
                myBetEl.classList.add("hidden");
              }
            }
          });

          // 헤더의 총 베팅 금액 업데이트
          const totalBetAmountEl = document.getElementById("totalBetAmount");
          if (totalBetAmountEl) {
            totalBetAmountEl.textContent = `총 베팅: ${totalBetAmount.toLocaleString()}원`;
          }
        }

        socket.on("my_bets_updated", (data) => {
          if (data && data.myCurrentBetsOnChoices) {
            currentBets = data.myCurrentBetsOnChoices; // 현재 베팅 상황 업데이트
            updateMyBetAmounts(data.myCurrentBetsOnChoices);
          }
        });
        // ##### 내 베팅액 관련 로직 끝 #####

        // 예측 관련 변수
        let currentPrediction = null;

        // 예측 표시 함수 (새로운 스코어보드와 호환)
        function addPrediction(predictionType) {
          // 기존 예측 제거
          removePrediction();

          const container = document.getElementById("recentResults");
          if (!container) return;

          // 새로운 예측 컬럼 생성
          const predictionColumn = document.createElement("div");
          predictionColumn.className = "result-column prediction-column";
          predictionColumn.id = "predictionColumn";

          // 예측 셀 생성
          const predictionElement = document.createElement("div");
          predictionElement.className = `result-cell ${predictionType} prediction`;
          predictionElement.style.position = "relative";
          predictionElement.title = "내 예측";

          predictionColumn.appendChild(predictionElement);
          container.appendChild(predictionColumn);

          // 스크롤을 맨 오른쪽으로
          container.scrollLeft = container.scrollWidth;

          currentPrediction = predictionType;
        }

        // 예측 제거 함수 (새로운 스코어보드와 호환)
        function removePrediction() {
          const predictionColumn = document.getElementById("predictionColumn");
          if (predictionColumn) {
            predictionColumn.remove();
          }
          currentPrediction = null;
        }

        // 예측 버튼 이벤트 리스너
        document
          .getElementById("predictPlayer")
          ?.addEventListener("click", () => {
            addPrediction("player");
          });

        document
          .getElementById("predictBanker")
          ?.addEventListener("click", () => {
            addPrediction("banker");
          });

        document.getElementById("predictTie")?.addEventListener("click", () => {
          addPrediction("tie");
        });

        // 초기화 호출들
        updateBettingStatsDisplay({
          player: { count: 0, total: 0, bettor_count: 0, total_bet_amount: 0 },
          banker: { count: 0, total: 0, bettor_count: 0, total_bet_amount: 0 },
          tie: { count: 0, total: 0, bettor_count: 0, total_bet_amount: 0 },
          player_pair: {
            count: 0,
            total: 0,
            bettor_count: 0,
            total_bet_amount: 0,
          },
          banker_pair: {
            count: 0,
            total: 0,
            bettor_count: 0,
            total_bet_amount: 0,
          },
        });
        fetchUserInfo(true); // 초기 로드는 즉시 실행
        fetchRecentGames();
        // 페이지 로드 시 카드 표시 초기화 (서버에 요청하는 대신 직접 클리어 또는 서버가 연결시 보내주는 이벤트 활용)
        // socket.emit("clear_cards_on_user_ui"); // 이 부분은 서버 로직으로 대체됨
        document
          .querySelectorAll(".player-cards .card-slot")
          .forEach((slot) => (slot.textContent = ""));
        document
          .querySelectorAll(".banker-cards .card-slot")
          .forEach((slot) => (slot.textContent = ""));

        setInterval(fetchRecentGames, 30000);

        document
          .getElementById("submitExchange")
          ?.addEventListener("click", async () => {
            const submitButton = document.getElementById("submitExchange");
            const amountValue = parseInt(exchangeAmountInput?.value || "0");

            if (!amountValue || isNaN(amountValue) || amountValue < 5000) {
              showNotification(
                "올바른 환전 금액을 입력해주세요. (최소 5,000원)"
              );
              return;
            }
            if (submitButton) {
              submitButton.disabled = true;
              submitButton.textContent = "처리중...";
            }
            try {
              const response = await fetch(
                "https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/exchange/request",
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${token}`,
                  },
                  body: JSON.stringify({ amount: amountValue }),
                }
              );
              const data = await response.json();
              if (response.ok) {
                // 환전 완료 모달 표시
                showExchangeRequestModal(amountValue, data.newBalance);

                if (chargeExchangeModal)
                  chargeExchangeModal.classList.add("hidden");
                if (exchangeAmountInput) exchangeAmountInput.value = "";
                if (exchangePreview) exchangePreview.classList.add("hidden");
                await fetchUserInfo();
                await fetchExchangeHistory();
              } else {
                showNotification(data.message || "환전 신청에 실패했습니다.");
              }
            } catch (error) {
              console.error("환전 신청 에러:", error);
              showNotification("서버 연결 오류가 발생했습니다.");
            } finally {
              if (submitButton) {
                submitButton.disabled = false;
                submitButton.textContent = "환전 신청하기";
              }
            }
          });

        // 모달 열기/닫기 이벤트 리스너
        if (
          showChargeExchangeButton &&
          chargeExchangeModal &&
          closeChargeExchangeButton
        ) {
          showChargeExchangeButton.addEventListener("click", () => {
            fetchUserInfo(); // 모달 열기 전 최신 정보 로드
            chargeExchangeModal.classList.remove("hidden");
            switchTab("charge"); // 기본적으로 충전 탭 활성화
          });
          closeChargeExchangeButton.addEventListener("click", () => {
            chargeExchangeModal.classList.add("hidden");
          });
        }

        if (showHistoryButton && historyModal && closeHistoryButton) {
          showHistoryButton.addEventListener("click", () => {
            historyModal.classList.remove("hidden");
            fetchUserInfo(); // 베팅 기록은 fetchUserInfo에서 displayBettingHistory를 호출
          });
          closeHistoryButton.addEventListener("click", () => {
            historyModal.classList.add("hidden");
          });
        }

        if (showMyInfoButton && myInfoModal && closeMyInfoButton) {
          showMyInfoButton.addEventListener("click", () => {
            myInfoModal.classList.remove("hidden");
            switchMyInfoTab("overview"); // 기본적으로 개요 탭 활성화
            fetchDetailedUserInfo(); // 상세 정보 가져오기
          });
          closeMyInfoButton.addEventListener("click", () => {
            myInfoModal.classList.add("hidden");
          });
        }

        // 승리 메시지 표시 함수
        function showWinMessage(winnings) {
          if (winMessage) {
            const messageDiv = winMessage.querySelector("div");
            const winAmountDisplay =
              document.getElementById("winAmountDisplay");

            // 이긴 금액 표시
            if (winAmountDisplay && winnings) {
              winAmountDisplay.textContent = `${winnings.toLocaleString()}원`;
            }

            // 메시지 표시
            winMessage.classList.remove("hidden");
            messageDiv.classList.add("win-message-enter");

            // 승리 사운드 재생
            const playerWinSound = document.getElementById("playerWinSound");
            if (playerWinSound) {
              playerWinSound.play().catch(() => {});
            }

            // 1.2초 후 사라지는 애니메이션 시작
            setTimeout(() => {
              messageDiv.classList.remove("win-message-enter");
              messageDiv.classList.add("win-message-exit");

              // 애니메이션 완료 후 숨기기
              setTimeout(() => {
                winMessage.classList.add("hidden");
                messageDiv.classList.remove("win-message-exit");
              }, 300);
            }, 1200);
          }
        }

        // 내 정보 모달 탭 이벤트 리스너
        const overviewTab = document.getElementById("overviewTab");
        const bettingTab = document.getElementById("bettingTab");
        const financialTab = document.getElementById("financialTab");

        if (overviewTab)
          overviewTab.addEventListener("click", () =>
            switchMyInfoTab("overview")
          );
        if (bettingTab)
          bettingTab.addEventListener("click", () =>
            switchMyInfoTab("betting")
          );
        if (financialTab)
          financialTab.addEventListener("click", () =>
            switchMyInfoTab("financial")
          );

        // 환전 내역 가져오기 함수
        async function fetchExchangeHistory() {
          try {
            const res = await fetch(
              "https://port-0-baccrat-backend-m5l6sc488b056240.sel4.cloudtype.app/api/exchange/history",
              {
                headers: { Authorization: `Bearer ${token}` },
              }
            );
            if (res.ok) {
              const exchanges = await res.json();
              const exchangeHistoryList = document.getElementById(
                "exchangeHistoryList"
              );
              if (exchangeHistoryList) {
                exchangeHistoryList.innerHTML = ""; // 기존 내용 초기화
                if (exchanges.length === 0) {
                  exchangeHistoryList.innerHTML = `<div class="text-center text-gray-400 py-4">환전 내역이 없습니다.</div>`;
                  return;
                }
                exchanges.forEach((exchange) => {
                  const card = createExchangeHistoryCard(exchange); // 이미 정의된 함수 사용
                  exchangeHistoryList.appendChild(card);
                });
              }
            } else {
              showNotification("환전 내역을 가져오는 데 실패했습니다.");
            }
          } catch (err) {
            console.error("환전 내역 조회 에러:", err);
            showNotification("서버 연결 오류가 발생했습니다.");
          }
        }

        // 환전 금액 입력 및 미리보기 로직
        if (
          exchangeAmountInput &&
          requestAmountSpan &&
          feeAmountSpan &&
          actualAmountSpan &&
          exchangePreview &&
          modalCoinBalance2 &&
          rollingInfoDiv &&
          submitExchangeButton
        ) {
          exchangeAmountInput.addEventListener("input", () => {
            const amount = parseInt(exchangeAmountInput.value);

            if (isNaN(amount) || amount <= 0) {
              exchangePreview.classList.add("hidden");
              submitExchangeButton.disabled = true;
              return;
            }

            // 수수료 정책 (환전액의 10%)
            const fee = Math.floor(amount * 0.1);
            const actual = amount - fee;

            requestAmountSpan.textContent = `${amount.toLocaleString()}원`;
            feeAmountSpan.textContent = `${fee.toLocaleString()}원`;
            actualAmountSpan.textContent = `${actual.toLocaleString()}원`;
            exchangePreview.classList.remove("hidden");

            // 환전 가능 금액 가져오기
            const maxExchangeText = document
              .getElementById("maxExchangeAmount")
              .textContent.replace(/[^0-9]/g, "");
            const maxExchangeAmount = parseInt(maxExchangeText) || 0;

            if (amount < 5000 || amount > maxExchangeAmount) {
              submitExchangeButton.disabled = true;
            } else {
              submitExchangeButton.disabled = false;
            }
          });
        }

        // 환전 모달 '최대' 버튼 클릭 리스너
        if (
          maxAmountButton &&
          exchangeAmountInput &&
          modalCoinBalance2 &&
          rollingInfoDiv
        ) {
          maxAmountButton.addEventListener("click", () => {
            // 환전 가능 금액 가져오기
            const maxExchangeText = document
              .getElementById("maxExchangeAmount")
              .textContent.replace(/[^0-9]/g, "");
            const maxExchangeAmount = parseInt(maxExchangeText) || 0;

            if (maxExchangeAmount > 0) {
              // 환전 가능 금액 설정
              exchangeAmountInput.value = maxExchangeAmount;
            } else {
              // 환전 가능 금액이 없음
              exchangeAmountInput.value = 0;
              showNotification(
                "환전 가능한 금액이 없습니다. 베팅을 먼저 해주세요."
              );
            }

            // 수동으로 input 이벤트 트리거하여 미리보기 업데이트
            exchangeAmountInput.dispatchEvent(new Event("input"));
          });
        }

        // Phaser 미니게임 Scene 정의
        class BaccaratSceneMini extends Phaser.Scene {
          constructor() {
            super({ key: "BaccaratSceneMini" });
            this.cardSprites = { player: [], banker: [] }; // Phaser Image 객체 저장
            this.handsData = { player: [], banker: [] }; // 카드 값(문자열) 저장
            this.socket = socket;

            // 화면 크기에 따른 반응형 설정
            this.setupResponsiveSettings();
          }

          setupResponsiveSettings() {
            const screenWidth = window.innerWidth;
            const isMobile = screenWidth < 1024; // lg 브레이크포인트

            if (isMobile) {
              // 모바일 설정 (기존 값 유지)
              this.cardScale = 0.3;
              this.cardSpacing = 45;
              this.baseFontSize = 14;
              this.scoreFontSize = 16;
              this.resultFontSize = 20;
            } else {
              // PC 설정 - 화면 크기에 따라 조정
              if (screenWidth >= 1920) {
                // 큰 PC 화면 (1920px 이상)
                this.cardScale = 0.5;
                this.cardSpacing = 70;
                this.baseFontSize = 20;
                this.scoreFontSize = 24;
                this.resultFontSize = 28;
              } else if (screenWidth >= 1440) {
                // 중간 PC 화면 (1440px 이상)
                this.cardScale = 0.45;
                this.cardSpacing = 65;
                this.baseFontSize = 18;
                this.scoreFontSize = 22;
                this.resultFontSize = 26;
              } else {
                // 작은 PC 화면 (1024px 이상)
                this.cardScale = 0.4;
                this.cardSpacing = 60;
                this.baseFontSize = 16;
                this.scoreFontSize = 20;
                this.resultFontSize = 24;
              }
            }
          }

          preload() {
            // 카드 이미지 프리로드 (모든 숫자와 무늬 조합)
            const suits = ["H", "D", "C", "S"]; // Hearts, Diamonds, Clubs, Spades (deckofcardsapi.com 형식)
            const values = [
              "A",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "0", // 0은 10을 의미
              "J",
              "Q",
              "K",
            ];

            suits.forEach((suit) => {
              values.forEach((value) => {
                // deckofcardsapi.com에서 사용하는 카드 코드 생성 (예: AH, 2S, 0D 등)
                const cardCode = `${value}${suit}`;
                const imageUrl = `https://deckofcardsapi.com/static/img/${cardCode}.png`;

                // 로드 에러 핸들러 추가
                this.load.image(cardCode, imageUrl);
                this.load.on(`loaderror`, (file) => {
                  if (file.key === cardCode) {
                    console.error(
                      `[MiniGame] Failed to load: ${cardCode} from ${imageUrl}`
                    );
                  }
                });
              });
            });

            // 예비용 또는 기본 카드 이미지 (선택 사항)
            this.load.image(
              "card_back",
              "https://deckofcardsapi.com/static/img/back.png"
            );
          }

          create() {
            const width = this.cameras.main.width;
            const height = this.cameras.main.height;
            const centerX = width / 2;
            const centerY = height / 2;

            // 바카라 테이블 배경 생성
            this.createBaccaratTable(width, height, centerX, centerY);

            // 텍스트 스타일 정의 (반응형)
            const textStyle = {
              fontSize: `${this.baseFontSize}px`,
              fontFamily: '"Noto Serif KR", serif',
              color: "#ffffff",
              stroke: "#000000",
              strokeThickness: 2,
            };
            const scoreTextStyle = {
              ...textStyle,
              fontSize: `${this.scoreFontSize}px`,
              color: "#ffd700",
              fontWeight: "bold",
            };
            const resultTextStyle = {
              ...textStyle,
              fontSize: `${this.resultFontSize}px`,
              color: "#FFD700",
              backgroundColor: "rgba(0,0,0,0.8)",
              padding: { x: 12, y: 6 },
              borderRadius: 8,
              fontWeight: "bold",
            };

            // 플레이어/뱅커 라벨
            this.add.text(centerX / 2, 25, "PLAYER", textStyle).setOrigin(0.5);
            this.add
              .text(centerX + centerX / 2, 25, "BANKER", textStyle)
              .setOrigin(0.5);

            // 점수 텍스트
            this.playerScoreText = this.add
              .text(centerX / 2, height - 25, "", scoreTextStyle)
              .setOrigin(0.5);
            this.bankerScoreText = this.add
              .text(centerX + centerX / 2, height - 25, "", scoreTextStyle)
              .setOrigin(0.5);

            // 게임 결과 텍스트
            this.gameResultText = this.add
              .text(centerX, centerY + 30, "", resultTextStyle)
              .setOrigin(0.5)
              .setVisible(false)
              .setDepth(10);

            this.clearAllCardsAndText();
          }

          createBaccaratTable(width, height, centerX, centerY) {
            const g = this.add.graphics();

            // 테이블 배경: 진한, 고급스러운 녹색
            const feltColor = 0x043521;
            g.fillStyle(feltColor, 1);
            g.fillRoundedRect(0, 0, width, height, 12);

            // PLAYER, BANKER 영역에 은은한 하이라이트
            g.fillStyle(0xffffff, 0.03);
            g.fillRoundedRect(10, 40, centerX - 20, height - 80, 10);
            g.fillRoundedRect(centerX + 10, 40, centerX - 20, height - 80, 10);
          }

          // 카드 값 계산 (game.html에서 가져옴) - NaN 방지 개선
          calculateCardValue(cardChar) {
            // 입력값 검증
            if (!cardChar || typeof cardChar !== "string") {
              return 0;
            }

            // 10, J, Q, K는 0점 (T는 10을 의미하므로 0점)
            if (["J", "Q", "K", "0", "T"].includes(cardChar)) return 0;

            // A는 1점
            if (cardChar === "A") return 1;

            // 숫자 카드 처리 (2-9)
            const numValue = parseInt(cardChar);
            if (isNaN(numValue)) {
              return 0; // NaN 대신 0 반환
            }

            return numValue;
          }

          calculateHandValue(handData) {
            // handData는 ['A', 'K'] 와 같은 문자열 배열
            if (!Array.isArray(handData)) {
              return 0;
            }

            let value = 0;
            for (let cardChar of handData) {
              const cardValue = this.calculateCardValue(cardChar);
              if (isNaN(cardValue)) {
                continue; // NaN인 카드는 건너뛰기
              }
              value = (value + cardValue) % 10;
            }
            return value;
          }

          displayCard(
            target,
            cardValueFromServer,
            cardSuitFromServer,
            cardIndex,
            isNewHand
          ) {
            // 입력값 검증
            if (!cardValueFromServer || !cardSuitFromServer) {
              return;
            }

            const width = this.cameras.main.width;
            const height = this.cameras.main.height;
            const centerX = width / 2;
            const cardY = height / 2; // 중앙 높이로 조정

            let actualCardValue = cardValueFromServer; // 'A', '2', ..., '9', '0', 'J', 'Q', 'K'
            // 서버에서 이미 '0'으로 오는 10, J, Q, K는 cardKey 생성 시 그대로 사용
            // deckofcardsapi.com은 10을 0으로 표현 (예: 0H, 0S)

            const suitInitial = cardSuitFromServer.charAt(0).toUpperCase(); // 'H', 'D', 'C', 'S'
            const cardKey = `${actualCardValue}${suitInitial}`;

            let handDataRef = this.handsData[target];
            let cardSpritesRef = this.cardSprites[target];
            let baseStartX;

            // 카드의 기본 X 위치 설정 (안전한 여백 확보)
            const cardWidth = 70 * this.cardScale; // 대략적인 카드 너비
            const safeMargin = cardWidth + 15; // 안전 여백 (더 넉넉하게)

            if (target === "player") {
              baseStartX = Math.max(safeMargin, centerX * 0.45); // 플레이어 영역
            } else {
              // banker
              baseStartX = Math.min(width - safeMargin, centerX * 1.55); // 뱅커 영역
            }

            // 카드 데이터 저장 (값 검증 추가)
            // 배열 크기를 cardIndex+1로 확장
            while (handDataRef.length <= cardIndex) {
              handDataRef.push(null);
            }
            handDataRef[cardIndex] = actualCardValue;

            // 현재 카드 생성/업데이트
            let cardSprite;
            try {
              if (
                cardSpritesRef[cardIndex] &&
                cardSpritesRef[cardIndex].scene &&
                !cardSpritesRef[cardIndex].scene.sys.isDestroyed &&
                cardSpritesRef[cardIndex].texture
              ) {
                // 기존 스프라이트가 있고, 파괴되지 않았다면
                cardSprite = cardSpritesRef[cardIndex];
                if (cardSprite.setTexture && typeof cardSprite.setTexture === 'function') {
                  cardSprite.setTexture(cardKey);
                  cardSprite.setAlpha(0).setScale(this.cardScale * 0.8);
                  cardSprite.setPosition(baseStartX, cardY - 100);
                } else {
                  // 스프라이트가 손상된 경우 새로 생성
                  cardSprite = null;
                }
              }
              
              if (!cardSprite) {
                // 새 스프라이트 생성
                cardSprite = this.add.image(
                  baseStartX, // 임시 위치
                  cardY - 100, // 시작 위치를 위쪽으로
                  cardKey
                );
                cardSpritesRef[cardIndex] = cardSprite; // 새 스프라이트를 배열에 저장
                cardSprite.setScale(this.cardScale * 0.8).setAlpha(0);

                // 카드 깊이 설정
                cardSprite.setDepth(5);
              }

              // 카드 뒤집기 애니메이션 (카드 뒷면 -> 앞면)
              // 먼저 카드 뒷면으로 시작
              cardSprite.setTexture("card_back");

              // 1단계: 카드 뒷면으로 등장
              this.tweens.add({
                targets: cardSprite,
                alpha: 1,
                y: cardY,
                scaleX: this.cardScale,
                scaleY: this.cardScale,
                duration: 300,
                ease: "Power2", // 부드러운 이징으로 변경 (움찔거림 제거)
                onComplete: () => {
                  // 2단계: 카드 뒤집기 (X축 스케일 0으로 -> 원래 카드로 변경 -> X축 스케일 복원)
                  this.tweens.add({
                    targets: cardSprite,
                    scaleX: 0,
                    duration: 150,
                    ease: "Power2",
                    onComplete: () => {
                      // 카드 스프라이트가 여전히 유효한지 확인
                      if (cardSprite && cardSprite.scene && !cardSprite.scene.sys.isDestroyed) {
                        try {
                          // 카드 텍스처를 앞면으로 변경
                          cardSprite.setTexture(cardKey);
                          // X축 스케일 복원
                          this.tweens.add({
                            targets: cardSprite,
                            scaleX: this.cardScale,
                            duration: 150,
                            ease: "Power2",
                          });
                        } catch (error) {
                          console.error(`[MiniGame] Error setting texture for card ${cardKey}:`, error);
                        }
                      }
                    },
                  });
                },
              });
            } catch (error) {
              console.error(
                `[MiniGame] Error displaying card ${cardKey}:`,
                error
              );
            }

            // 모든 카드의 위치를 다시 계산하고 업데이트
            this.repositionAllCards(target);

            this.updateScores();
          }

          // 모든 카드의 위치를 다시 계산하여 배치하는 함수
          repositionAllCards(target) {
            const width = this.cameras.main.width;
            const centerX = width / 2;
            let baseStartX;

            // 카드의 기본 X 위치 설정 (안전한 여백 확보)
            const cardWidth = 70 * this.cardScale; // 대략적인 카드 너비
            const safeMargin = cardWidth + 15; // 안전 여백 (더 넉넉하게)

            if (target === "player") {
              baseStartX = Math.max(safeMargin, centerX * 0.45); // 플레이어 영역
            } else {
              baseStartX = Math.min(width - safeMargin, centerX * 1.55); // 뱅커 영역
            }

            const handDataRef = this.handsData[target];
            const cardSpritesRef = this.cardSprites[target];

            // 실제 존재하는 카드 수 계산 (null이 아닌 카드들)
            const existingCards = [];
            for (let i = 0; i < handDataRef.length; i++) {
              if (
                handDataRef[i] !== null &&
                cardSpritesRef[i] &&
                cardSpritesRef[i].scene &&
                !cardSpritesRef[i].scene.sys.isDestroyed &&
                cardSpritesRef[i].texture &&
                typeof cardSpritesRef[i].setPosition === 'function'
              ) {
                existingCards.push({ index: i, sprite: cardSpritesRef[i] });
              }
            }

            const numCards = existingCards.length;

            // 카드 위치 계산 및 배치
            existingCards.forEach((cardInfo, position) => {
              let xOffset = 0;

              if (numCards === 1) {
                xOffset = 0; // 중앙
              } else if (numCards === 2) {
                xOffset =
                  position === 0 ? -this.cardSpacing / 2 : this.cardSpacing / 2;
              } else if (numCards === 3) {
                if (position === 0) xOffset = -this.cardSpacing;
                else if (position === 1) xOffset = 0;
                else xOffset = this.cardSpacing;
              }

              const finalX = baseStartX + xOffset;

              // 화면 경계 체크 및 조정
              const adjustedX = Math.max(
                safeMargin / 2,
                Math.min(width - safeMargin / 2, finalX)
              );

              // 카드 위치 부드럽게 이동
              this.tweens.add({
                targets: cardInfo.sprite,
                x: adjustedX,
                duration: 300,
                ease: "Power2",
              });
            });
          }

          clearCards(target) {
            let cardSpritesToClear = this.cardSprites[target];
            let handDataToClear = this.handsData[target];

            cardSpritesToClear.forEach((sprite) => {
              if (sprite && typeof sprite.destroy === "function") {
                try {
                  // 스프라이트가 이미 파괴되지 않았는지 확인
                  if (sprite.scene && !sprite.scene.sys.isDestroyed) {
                    sprite.destroy();
                  }
                } catch (error) {
                  console.warn('[MiniGame] Error destroying sprite:', error);
                }
              }
            });
            cardSpritesToClear.length = 0;
            handDataToClear.length = 0;

            this.updateScores();
          }

          updateScores() {
            const playerScore = this.calculateHandValue(
              this.handsData.player // handsData 사용
            );
            const bankerScore = this.calculateHandValue(
              this.handsData.banker // handsData 사용
            );

            // NaN 체크 및 안전한 표시
            const safePlayerScore = isNaN(playerScore) ? 0 : playerScore;
            const safeBankerScore = isNaN(bankerScore) ? 0 : bankerScore;

            this.playerScoreText.setText(`P: ${safePlayerScore}`);
            this.bankerScoreText.setText(`B: ${safeBankerScore}`);
          }

          setGameResult(result, pScore, bScore) {
            let message = "";
            let resultColor = "#FFD700";

            if (result === "player") {
              message = `PLAYER WIN!\n(${pScore} vs ${bScore})`;
              resultColor = "#4169E1"; // 파란색
            } else if (result === "banker") {
              message = `BANKER WIN! \n(${pScore} vs ${bScore})`;
              resultColor = "#DC143C"; // 빨간색
            } else if (result === "tie") {
              message = `TIE\n(${pScore} vs ${bScore})`;
              resultColor = "#32CD32"; // 녹색
            }

            this.gameResultText.setText(message);
            this.gameResultText.setStyle({ color: resultColor });
            this.gameResultText.setVisible(true);
            this.gameResultText.setAlpha(0).setScale(0.5);

            // 부드러운 결과 텍스트 애니메이션
            this.tweens.add({
              targets: this.gameResultText,
              alpha: 1,
              scaleX: 1,
              scaleY: 1,
              duration: 400,
              ease: "Power2", // 더 부드러운 이징으로 변경
              onComplete: () => {
                // 부드러운 반짝이는 효과
                this.tweens.add({
                  targets: this.gameResultText,
                  alpha: 0.8,
                  duration: 800,
                  yoyo: true,
                  repeat: 2,
                  ease: "Sine.InOut",
                });
              },
            });

            // 배경 번쩍임 효과
            const flashGraphics = this.add.graphics();
            flashGraphics.fillStyle(0xffffff, 0.3);
            flashGraphics.fillRect(
              0,
              0,
              this.cameras.main.width,
              this.cameras.main.height
            );
            flashGraphics.setDepth(8);

            this.tweens.add({
              targets: flashGraphics,
              alpha: 0,
              duration: 500,
              ease: "Power2",
              onComplete: () => flashGraphics.destroy(),
            });
          }

          repositionCards() {
            // 기존 카드들을 새로운 반응형 설정에 맞게 다시 배치
            const width = this.cameras.main.width;
            const height = this.cameras.main.height;
            const centerX = width / 2;
            const cardY = height / 2;

            // 플레이어 카드 재배치
            this.cardSprites.player.forEach((cardInfo, index) => {
              if (cardInfo && cardInfo.sprite) {
                const cardWidth = 70 * this.cardScale;
                const safeMargin = cardWidth + 15;
                const baseStartX = Math.max(safeMargin, centerX * 0.45);
                const finalX = baseStartX + index * this.cardSpacing;
                const adjustedX = Math.max(
                  safeMargin / 2,
                  Math.min(width - safeMargin / 2, finalX)
                );

                cardInfo.sprite.setScale(this.cardScale);
                cardInfo.sprite.setPosition(adjustedX, cardY);
              }
            });

            // 뱅커 카드 재배치
            this.cardSprites.banker.forEach((cardInfo, index) => {
              if (cardInfo && cardInfo.sprite) {
                const cardWidth = 70 * this.cardScale;
                const safeMargin = cardWidth + 15;
                const baseStartX = Math.min(width - safeMargin, centerX * 1.55);
                const finalX = baseStartX + index * this.cardSpacing;
                const adjustedX = Math.max(
                  safeMargin / 2,
                  Math.min(width - safeMargin / 2, finalX)
                );

                cardInfo.sprite.setScale(this.cardScale);
                cardInfo.sprite.setPosition(adjustedX, cardY);
              }
            });

            // 텍스트 스타일도 업데이트
            if (this.playerScoreText) {
              this.playerScoreText.setStyle({
                fontSize: `${this.scoreFontSize}px`,
              });
            }
            if (this.bankerScoreText) {
              this.bankerScoreText.setStyle({
                fontSize: `${this.scoreFontSize}px`,
              });
            }
            if (this.gameResultText) {
              this.gameResultText.setStyle({
                fontSize: `${this.resultFontSize}px`,
              });
            }
          }

          clearAllCardsAndText() {
            this.clearCards("player");
            this.clearCards("banker");
            this.playerScoreText.setText("P: 0");
            this.bankerScoreText.setText("B: 0");
            if (this.gameResultText) {
              this.gameResultText.setVisible(false);
            }
          }
        }

        // Phaser 게임 시작 함수
        function startMiniGame() {
          const container = document.getElementById("miniGameContainer");
          if (!container) {
            console.error("miniGameContainer not found!");
            return;
          }

          const config = {
            type: Phaser.AUTO, // AUTO는 WebGL 우선, 안되면 Canvas 사용
            parent: "miniGameContainer",
            width: container.clientWidth, // 컨테이너 너비에 맞춤
            height: container.clientHeight, // 컨테이너 높이에 맞춤
            transparent: true, // 배경 투명하게
            scene: BaccaratSceneMini,
            scale: {
              mode: Phaser.Scale.FIT, // 컨테이너에 맞게 스케일 조정
              autoCenter: Phaser.Scale.CENTER_BOTH,
            },
          };
          if (miniGame) {
            // 기존 게임 인스턴스가 있다면 파괴
            miniGame.destroy(true);
          }
          miniGame = new Phaser.Game(config);

          // Scene 인스턴스를 게임의 'ready' 이벤트 발생 시점에 가져옵니다.
          // 이렇게 하면 Scene Manager가 Scene을 처리할 충분한 시간을 갖게 됩니다.
          miniGame.events.on("ready", () => {
            if (miniGame && miniGame.scene) {
              baccaratSceneMini = miniGame.scene.getScene("BaccaratSceneMini");
              if (!baccaratSceneMini) {
                console.error(
                  "BaccaratSceneMini 인스턴스를 game READY 이벤트 후에도 가져올 수 없습니다. 소켓 이벤트 연동에 문제가 있을 수 있습니다."
                );
              } else {
              }
            } else {
              console.error(
                "Phaser Game 또는 Scene Manager가 game READY 이벤트 시점에 유효하지 않습니다."
              );
            }
          });
        }

        // 창 크기 변경 시 게임 리사이즈 및 반응형 설정 재적용
        window.addEventListener("resize", () => {
          if (miniGame && miniGame.scene) {
            const container = document.getElementById("miniGameContainer");
            if (container) {
              try {
                // 반응형 설정 재적용
                if (baccaratSceneMini && baccaratSceneMini.sys && baccaratSceneMini.sys.isActive() && !baccaratSceneMini.sys.isDestroyed) {
                  if (typeof baccaratSceneMini.setupResponsiveSettings === 'function') {
                    baccaratSceneMini.setupResponsiveSettings();
                  }
                  // 기존 카드들을 새로운 설정으로 다시 배치
                  if (typeof baccaratSceneMini.repositionCards === 'function') {
                    baccaratSceneMini.repositionCards();
                  }
                }
              } catch (error) {
                console.warn('[MiniGame] Error during resize handling:', error);
              }
            }
          }
        });

        // DOMContentLoaded 이후 게임 시작 및 Socket 이벤트 핸들러 수정/추가
        startMiniGame(); // 페이지 로드 시 미니게임 시작
        


        // 기존 카드 표시 이벤트 (game.html 호환)
        socket.on("display_card_on_user_html", (data) => {
          try {
            if (baccaratSceneMini && baccaratSceneMini.sys && baccaratSceneMini.sys.isActive() && !baccaratSceneMini.sys.isDestroyed) {
              const { target, cardValue, cardSuit, cardIndex, isNewHand } = data;
              if (isNewHand && cardIndex === 0) {
                if (typeof baccaratSceneMini.clearCards === 'function') {
                  baccaratSceneMini.clearCards(
                    target === "player" ? "player" : "banker"
                  ); // 해당 타겟의 카드만 클리어
                }
              }
              if (typeof baccaratSceneMini.displayCard === 'function') {
                baccaratSceneMini.displayCard(
                  target,
                  cardValue,
                  cardSuit,
                  cardIndex,
                  isNewHand
                );
              }
            }
          } catch (error) {
            console.warn("[MiniGame] Error in display_card_on_user_html:", error);
          }
        });

        // 새로운 카드 표시 이벤트 (admin 시스템 호환)
        socket.on("card_dealt_to_user_ui", (data) => {
          try {
            if (baccaratSceneMini && baccaratSceneMini.sys && baccaratSceneMini.sys.isActive() && !baccaratSceneMini.sys.isDestroyed) {
              const { target, cardValue, cardSuit, cardIndex, isNewHand } = data;
              if (isNewHand && cardIndex === 0) {
                if (typeof baccaratSceneMini.clearCards === 'function') {
                  baccaratSceneMini.clearCards(
                    target === "player" ? "player" : "banker"
                  ); // 해당 타겟의 카드만 클리어
                }
              }
              if (typeof baccaratSceneMini.displayCard === 'function') {
                baccaratSceneMini.displayCard(
                  target,
                  cardValue,
                  cardSuit,
                  cardIndex,
                  isNewHand
                );
              }
            }
          } catch (error) {
            console.warn("[MiniGame] Error in card_dealt_to_user_ui:", error);
          }
        });

        socket.on("clear_cards_display_on_user_html", () => {
          try {
            if (baccaratSceneMini && baccaratSceneMini.sys && baccaratSceneMini.sys.isActive() && !baccaratSceneMini.sys.isDestroyed) {
              if (typeof baccaratSceneMini.clearAllCardsAndText === 'function') {
                baccaratSceneMini.clearAllCardsAndText();
              }
            }
          } catch (error) {
            console.warn("[MiniGame] Error in clear_cards_display_on_user_html:", error);
          }
        });
      }); // DOMContentLoaded event listener 닫기
    </script>
  </body>
</html>
